GROUND TRUTH:
---
+++
@@ -1,3 +1,3 @@
     private boolean toStringEquals(Matcher m, Object arg) {
-        return StringDescription.toString(m).equals(arg.toString());
+        return StringDescription.toString(m).equals(arg == null? "null" : arg.toString());
     }

PLAUSIBLE PATCH:
---
+++
@@ -1,3 +1,5 @@
     private boolean toStringEquals(Matcher m, Object arg) {
-        return StringDescription.toString(m).equals(arg.toString());
+// buggy code
+//         return StringDescription.toString(m).equals(arg.toString());
+       return StringDescription.toString(m).equals(String.valueOf(arg));
     }

toString() result might not be the same as String.valueOf() (you can override the function toString)
Mockito-38

-------------------------------------------------------------------------------

GROUND TRUTH:
+                found = key.equals(_hashArea[i-1]);
PLAUSIBLE PATCH:
+               found = key.equals(getPropertyName(prop));

I don't understand why this is semantically equivalent?
JacksonDatabind-70


----------------------------------------------------------------------------------

GROUND TRUTH:
---
+++
@@ -1,16 +1,15 @@
     private void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException {
         int cache = 0;
         int shift = 7;
         for (int i = 0; i < length; i++) {
             cache |= ((bits.get(i) ? 1 : 0) << shift);
-            --shift;
-            if (shift == 0) {
+            if (--shift < 0) {
                 header.write(cache);
                 shift = 7;
                 cache = 0;
             }
         }
-        if (length > 0 && shift > 0) {
+        if (shift != 7) {
             header.write(cache);
         }
     }

PLAUSIBLE PATCH:
---
+++
@@ -1,16 +1,26 @@
     private void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException {
         int cache = 0;
         int shift = 7;
         for (int i = 0; i < length; i++) {
             cache |= ((bits.get(i) ? 1 : 0) << shift);
-            --shift;
-            if (shift == 0) {
+           if (shift == 0) {
                 header.write(cache);
                 shift = 7;
                 cache = 0;
+            } else {
+                --shift;
             }
         }
-        if (length > 0 && shift > 0) {
+        if (shift < 7) {
             header.write(cache);
         }
     }

This is not the same. The reference solution **always** does --shift, not just when shift != 0
Compress-21

----------------------------------------------------------------------------------------------------------------------------------

GROUND TRUTH:
---
+++
@@ -1,28 +1,25 @@
   void addNumber(double x) {
-    // This is not pretty printing. This is to prevent misparsing of x- -4 as
-    // x--4 (which is a syntax error).
     char prev = getLastChar();
     boolean negativeZero = isNegativeZero(x);
-    if (x < 0 && prev == '-') {
+    if ((x < 0 || negativeZero) && prev == '-') {
       add(" ");
     }

PLAUSIBLE PATCH:
---
+++
@@ -1,28 +1,27 @@
   void addNumber(double x) {
-    // This is not pretty printing. This is to prevent misparsing of x- -4 as
-    // x--4 (which is a syntax error).
     char prev = getLastChar();
     boolean negativeZero = isNegativeZero(x);
-    if (x < 0 && prev == '-') {
+// buggy code
+//     if (x < 0 && prev == '-') {
+   if ((x < 0 && prev == '-') || (x == 0 && prev == '-')) {
       add(" ");
     }


This might not be the same. We do not know what the function "isNegativeZero(x)" does. Since the reference solution uses the value
returned by it, and ours does not, we cannot say it is semantically equivalent imo.

Closure-38


-----------------------------------------------------------------------------------------------------------------------------------

GROUND TRUTH:
+            if (tree.getCut() == null && (Boolean) tree.getAttribute()) {
PLAUSIBLE PATCH:
+           if (tree != null && Boolean.TRUE.equals(tree.getAttribute())) {

Different condition, not semantically equivalent imo
Math-32

-------------------------------------------------------------------------------------------------------------------------
GROUND TRUTH:
+            if (!raw.isInterface() && full.startsWith(PREFIX_STRING)) {
+                for (Class<?> cls = raw; (cls != null) && (cls != Object.class); cls = cls.getSuperclass()) {
PLAUSIBLE:
+           if (full.startsWith(PREFIX_STRING)) {
+                for (Class<?> cls = raw; cls != null; cls = cls.getSuperclass()) {

Different condition, not semantically equivalent imo
JacksonDatabind-93

-----------------------------------------------------------------------------------------------------------------------
GROUND TRUTH:
+        if (chars != null && chars.length == 0) {
+            throw new IllegalArgumentException("The chars array must not be empty");
+        }
         if (start == 0 && end == 0) {
+            if (chars != null) {
+                end = chars.length;
+            } else {
PLAUSIBLE:
+       if (start == 0 && end == 0 && chars == null) {
                 if (!letters && !numbers) {
                     end = Integer.MAX_VALUE;
                 } else {
                     end = 'z' + 1;
                     start = ' ';
                 }
+        } else {
+            if (chars != null) {
+                end = chars.length;
+            }

Not the same, where is the exception?
Lang-12

---------------------------------------------------------------------------
GROUND TRUTH:
-            // loop through the required options
             while (iter.hasNext())
             {
                 buff.append(iter.next());
+                buff.append(", ");
             }
-
-            throw new MissingOptionException(buff.toString());
+            throw new MissingOptionException(buff.substring(0, buff.length() - 2));
PLAUSIBLE:
             while (iter.hasNext())
             {
                 buff.append(iter.next());
+               if (iter.hasNext())
+                {
+                    buff.append(", ");
+                }
             }

This is not the same because the "iter.hasNext()" value can change after the "inter.next()" method is called.
Note that the reference append does not require the hasNext()
Cli-9

---------------------------------------------------------------------------------
GROUND TRUTH:
---
+++
@@ -1,3 +1,3 @@
     public static String newStringIso8859_1(final byte[] bytes) {
-        return new String(bytes, Charsets.ISO_8859_1);
+        return newString(bytes, Charsets.ISO_8859_1);
     }

PLAUSIBLE PATCH:
---
+++
@@ -1,3 +1,5 @@
     public static String newStringIso8859_1(final byte[] bytes) {
-        return new String(bytes, Charsets.ISO_8859_1);
+       return bytes == null ? null : new String(bytes, Charsets.ISO_8859_1);
     }

Not the same. The difference in the reference is that the method "newString" is called? We do not know what it does.
Codec-17
------------------------------------------------------------------------------------------------
GROUND TRUTH:
---
+++
@@ -1,3 +1,3 @@
     public String getValue() {
-        return val;
+        return Attributes.checkNotNull(val);
     }

PLAUSIBLE PATCH:
---
+++
@@ -1,3 +1,5 @@
     public String getValue() {
-        return val;
+       return val == null ? "" : val;
     }

This is tricky because we do not know that "checkNotNull" does nor returns. I would not call this semantically equivalent without checking.
Jsoup-88

---------------------------------------------------------------------------------------------------
