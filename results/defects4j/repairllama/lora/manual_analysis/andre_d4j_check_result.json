{"bug_id": "Jsoup-40", "buggy_code": "    public DocumentType(String name, String publicId, String systemId, String baseUri) {\n        super(baseUri);\n\n        Validate.notEmpty(name);\n        attr(\"name\", name);\n        attr(\"publicId\", publicId);\n        attr(\"systemId\", systemId);\n    }\n", "fixed_code": "    public DocumentType(String name, String publicId, String systemId, String baseUri) {\n        super(baseUri);\n        attr(\"name\", name);\n        attr(\"publicId\", publicId);\n        attr(\"systemId\", systemId);\n    }\n", "test_results": ["Plausible"], "patches": ["    public DocumentType(String name, String publicId, String systemId, String baseUri) {\n        super(baseUri);\n// buggy code\n//         Validate.notEmpty(name);\n       Validate.notNull(name);\n        attr(\"name\", name);\n        attr(\"publicId\", publicId);\n        attr(\"systemId\", systemId);\n    }\n"], "manual_results": [0]}
{"bug_id": "Codec-17", "buggy_code": "    public static String newStringIso8859_1(final byte[] bytes) {\n        return new String(bytes, Charsets.ISO_8859_1);\n    }\n", "fixed_code": "    public static String newStringIso8859_1(final byte[] bytes) {\n        return newString(bytes, Charsets.ISO_8859_1);\n    }\n", "test_results": ["Plausible"], "patches": ["    public static String newStringIso8859_1(final byte[] bytes) {\n// buggy code\n//         return new String(bytes, Charsets.ISO_8859_1);\n       return bytes == null ? null : new String(bytes, Charsets.ISO_8859_1);\n    }\n"], "manual_results": [0]}
{"bug_id": "Time-7", "buggy_code": "    public int parseInto(ReadWritableInstant instant, String text, int position) {\n        DateTimeParser parser = requireParser();\n        if (instant == null) {\n            throw new IllegalArgumentException(\"Instant must not be null\");\n        }\n        \n        long instantMillis = instant.getMillis();\n        Chronology chrono = instant.getChronology();\n        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n        chrono = selectChronology(chrono);\n        int defaultYear = chrono.year().get(instantLocal);\n        \n        DateTimeParserBucket bucket = new DateTimeParserBucket(\n            instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n        int newPos = parser.parseInto(bucket, text, position);\n        instant.setMillis(bucket.computeMillis(false, text));\n        if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n            int parsedOffset = bucket.getOffsetInteger();\n            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n            chrono = chrono.withZone(parsedZone);\n        } else if (bucket.getZone() != null) {\n            chrono = chrono.withZone(bucket.getZone());\n        }\n        instant.setChronology(chrono);\n        if (iZone != null) {\n            instant.setZone(iZone);\n        }\n        return newPos;\n    }\n", "fixed_code": "    public int parseInto(ReadWritableInstant instant, String text, int position) {\n        DateTimeParser parser = requireParser();\n        if (instant == null) {\n            throw new IllegalArgumentException(\"Instant must not be null\");\n        }\n        long instantMillis = instant.getMillis();\n        Chronology chrono = instant.getChronology();\n        int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis);\n        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n        chrono = selectChronology(chrono);\n        DateTimeParserBucket bucket = new DateTimeParserBucket(\n            instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n        int newPos = parser.parseInto(bucket, text, position);\n        instant.setMillis(bucket.computeMillis(false, text));\n        if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n            int parsedOffset = bucket.getOffsetInteger();\n            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n            chrono = chrono.withZone(parsedZone);\n        } else if (bucket.getZone() != null) {\n            chrono = chrono.withZone(bucket.getZone());\n        }\n        instant.setChronology(chrono);\n        if (iZone != null) {\n            instant.setZone(iZone);\n        }\n        return newPos;\n    }\n", "test_results": ["Plausible", "Plausible"], "patches": ["    public int parseInto(ReadWritableInstant instant, String text, int position) {\n        DateTimeParser parser = requireParser();\n        if (instant == null) {\n            throw new IllegalArgumentException(\"Instant must not be null\");\n        }\n        long instantMillis = instant.getMillis();\n        Chronology chrono = instant.getChronology();\n// buggy code\n//         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n//         chrono = selectChronology(chrono);\n//         int defaultYear = chrono.year().get(instantLocal);\n       int defaultYear = chrono.year().get(instantMillis);\n        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n        chrono = selectChronology(chrono);\n        DateTimeParserBucket bucket = new DateTimeParserBucket(\n            instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n        int newPos = parser.parseInto(bucket, text, position);\n        instant.setMillis(bucket.computeMillis(false, text));\n        if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n            int parsedOffset = bucket.getOffsetInteger();\n            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n            chrono = chrono.withZone(parsedZone);\n        } else if (bucket.getZone() != null) {\n            chrono = chrono.withZone(bucket.getZone());\n        }\n        instant.setChronology(chrono);\n        if (iZone != null) {\n            instant.setZone(iZone);\n        }\n        return newPos;\n    }\n", "    public int parseInto(ReadWritableInstant instant, String text, int position) {\n        DateTimeParser parser = requireParser();\n        if (instant == null) {\n            throw new IllegalArgumentException(\"Instant must not be null\");\n        }\n        long instantMillis = instant.getMillis();\n        Chronology chrono = instant.getChronology();\n// buggy code\n//         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n//         chrono = selectChronology(chrono);\n//         int defaultYear = chrono.year().get(instantLocal);\n       long instantLocal = instantMillis;\n        if (chrono.getZone() != null) {\n            instantLocal += chrono.getZone().getOffset(instantMillis);\n        }\n        chrono = selectChronology(chrono);\n        int defaultYear = chrono.year().get(instantMillis);\n        DateTimeParserBucket bucket = new DateTimeParserBucket(\n            instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n        int newPos = parser.parseInto(bucket, text, position);\n        instant.setMillis(bucket.computeMillis(false, text));\n        if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n            int parsedOffset = bucket.getOffsetInteger();\n            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n            chrono = chrono.withZone(parsedZone);\n        } else if (bucket.getZone() != null) {\n            chrono = chrono.withZone(bucket.getZone());\n        }\n        instant.setChronology(chrono);\n        if (iZone != null) {\n            instant.setZone(iZone);\n        }\n        return newPos;\n    }\n"], "manual_results": [0, 0]}
{"bug_id": "Jsoup-88", "buggy_code": "    public String getValue() {\n        return val;\n    }\n", "fixed_code": "    public String getValue() {\n        return Attributes.checkNotNull(val);\n    }\n", "test_results": ["Plausible", "Plausible", "Plausible"], "patches": ["    public String getValue() {\n// buggy code\n//         return val;\n       return val == null ? \"\" : val;\n    }\n", "    public String getValue() {\n// buggy code\n//         return val;\n       return val != null ? val : \"\";\n    }\n", "    public String getValue() {\n// buggy code\n//         return val;\n       return (val == null) ? \"\" : val;\n    }\n"], "manual_results": [0, 0, 0]}
{"bug_id": "Jsoup-86", "buggy_code": "    public XmlDeclaration asXmlDeclaration() {\n        String data = getData();\n        Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n        XmlDeclaration decl = null;\n        if (doc.childNodeSize() > 0) {\n            Element el = doc.child(0);\n            decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith(\"!\"));\n            decl.attributes().addAll(el.attributes());\n        }\n        return decl;\n    }\n", "fixed_code": "    public XmlDeclaration asXmlDeclaration() {\n        String data = getData();\n        Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n        XmlDeclaration decl = null;\n        if (doc.children().size() > 0) {\n            Element el = doc.child(0);\n            decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith(\"!\"));\n            decl.attributes().addAll(el.attributes());\n        }\n        return decl;\n    }\n", "test_results": ["Plausible"], "patches": ["    public XmlDeclaration asXmlDeclaration() {\n        String data = getData();\n        Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n        XmlDeclaration decl = null;\n// buggy code\n//         if (doc.childNodeSize() > 0) {\n       if (doc.childNodeSize() > 0 && doc.childNode(0) instanceof Element) {\n            Element el = doc.child(0);\n            decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith(\"!\"));\n            decl.attributes().addAll(el.attributes());\n        }\n        return decl;\n    }\n"], "manual_results": [0]}
{"bug_id": "Compress-21", "buggy_code": "    private void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException {\n        int cache = 0;\n        int shift = 7;\n        for (int i = 0; i < length; i++) {\n            cache |= ((bits.get(i) ? 1 : 0) << shift);\n            --shift;\n            if (shift == 0) {\n                header.write(cache);\n                shift = 7;\n                cache = 0;\n            }\n        }\n        if (length > 0 && shift > 0) {\n            header.write(cache);\n        }\n    }\n", "fixed_code": "    private void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException {\n        int cache = 0;\n        int shift = 7;\n        for (int i = 0; i < length; i++) {\n            cache |= ((bits.get(i) ? 1 : 0) << shift);\n            if (--shift < 0) {\n                header.write(cache);\n                shift = 7;\n                cache = 0;\n            }\n        }\n        if (shift != 7) {\n            header.write(cache);\n        }\n    }\n", "test_results": ["Plausible", "Plausible", "Plausible"], "patches": ["    private void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException {\n        int cache = 0;\n        int shift = 7;\n        for (int i = 0; i < length; i++) {\n            cache |= ((bits.get(i) ? 1 : 0) << shift);\n// buggy code\n//             --shift;\n//             if (shift == 0) {\n//                 header.write(cache);\n//                 shift = 7;\n//                 cache = 0;\n//             }\n//         }\n//         if (length > 0 && shift > 0) {\n           if (shift == 0) {\n                header.write(cache);\n                shift = 7;\n                cache = 0;\n            } else {\n                --shift;\n            }\n        }\n        if (shift != 7) {\n            header.write(cache);\n        }\n    }\n", "    private void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException {\n        int cache = 0;\n        int shift = 7;\n        for (int i = 0; i < length; i++) {\n            cache |= ((bits.get(i) ? 1 : 0) << shift);\n// buggy code\n//             --shift;\n//             if (shift == 0) {\n//                 header.write(cache);\n//                 shift = 7;\n//                 cache = 0;\n//             }\n//         }\n//         if (length > 0 && shift > 0) {\n           if (shift == 0) {\n                header.write(cache);\n                shift = 7;\n                cache = 0;\n            } else {\n                --shift;\n            }\n        }\n        if (shift < 7) {\n            header.write(cache);\n        }\n    }\n", "    private void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException {\n        int cache = 0;\n        int shift = 7;\n        for (int i = 0; i < length; i++) {\n            cache |= ((bits.get(i) ? 1 : 0) << shift);\n// buggy code\n//             --shift;\n//             if (shift == 0) {\n//                 header.write(cache);\n//                 shift = 7;\n//                 cache = 0;\n//             }\n//         }\n//         if (length > 0 && shift > 0) {\n           if (shift == 0) {\n                header.write(cache);\n                shift = 7;\n                cache = 0;\n            } else {\n                shift--;\n            }\n        }\n        if (shift != 7) {\n            header.write(cache);\n        }\n    }\n"], "manual_results": [0, 0, 0]}
{"bug_id": "Jsoup-90", "buggy_code": "        private static boolean looksLikeUtf8(byte[] input) {\n            int i = 0;\n            // BOM:\n            if (input.length >= 3 && (input[0] & 0xFF) == 0xEF\n                && (input[1] & 0xFF) == 0xBB & (input[2] & 0xFF) == 0xBF) {\n                i = 3;\n            }\n\n            int end;\n            for (int j = input.length; i < j; ++i) {\n                int o = input[i];\n                if ((o & 0x80) == 0) {\n                    continue; // ASCII\n                }\n\n                // UTF-8 leading:\n                if ((o & 0xE0) == 0xC0) {\n                    end = i + 1;\n                } else if ((o & 0xF0) == 0xE0) {\n                    end = i + 2;\n                } else if ((o & 0xF8) == 0xF0) {\n                    end = i + 3;\n                } else {\n                    return false;\n                }\n\n\n                while (i < end) {\n                    i++;\n                    o = input[i];\n                    if ((o & 0xC0) != 0x80) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n", "fixed_code": "        private static boolean looksLikeUtf8(byte[] input) {\n            int i = 0;\n            if (input.length >= 3 && (input[0] & 0xFF) == 0xEF\n                && (input[1] & 0xFF) == 0xBB & (input[2] & 0xFF) == 0xBF) {\n                i = 3;\n            }\n            int end;\n            for (int j = input.length; i < j; ++i) {\n                int o = input[i];\n                if ((o & 0x80) == 0) {\n                    continue; \n                }\n                if ((o & 0xE0) == 0xC0) {\n                    end = i + 1;\n                } else if ((o & 0xF0) == 0xE0) {\n                    end = i + 2;\n                } else if ((o & 0xF8) == 0xF0) {\n                    end = i + 3;\n                } else {\n                    return false;\n                }\n                if (end >= input.length)\n                    return false;\n                while (i < end) {\n                    i++;\n                    o = input[i];\n                    if ((o & 0xC0) != 0x80) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n", "test_results": ["Plausible", "Plausible", "Plausible", "Plausible", "Plausible", "Plausible"], "patches": ["        private static boolean looksLikeUtf8(byte[] input) {\n            int i = 0;\n            if (input.length >= 3 && (input[0] & 0xFF) == 0xEF\n                && (input[1] & 0xFF) == 0xBB & (input[2] & 0xFF) == 0xBF) {\n                i = 3;\n            }\n            int end;\n            for (int j = input.length; i < j; ++i) {\n                int o = input[i];\n                if ((o & 0x80) == 0) {\n                    continue; \n                }\n                if ((o & 0xE0) == 0xC0) {\n                    end = i + 1;\n                } else if ((o & 0xF0) == 0xE0) {\n                    end = i + 2;\n                } else if ((o & 0xF8) == 0xF0) {\n                    end = i + 3;\n                } else {\n                    return false;\n                }\n// buggy code\n// \n               i = end;\n                while (i < end) {\n                    i++;\n                    o = input[i];\n                    if ((o & 0xC0) != 0x80) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n", "        private static boolean looksLikeUtf8(byte[] input) {\n            int i = 0;\n            if (input.length >= 3 && (input[0] & 0xFF) == 0xEF\n                && (input[1] & 0xFF) == 0xBB & (input[2] & 0xFF) == 0xBF) {\n                i = 3;\n            }\n            int end;\n            for (int j = input.length; i < j; ++i) {\n                int o = input[i];\n                if ((o & 0x80) == 0) {\n                    continue; \n                }\n                if ((o & 0xE0) == 0xC0) {\n                    end = i + 1;\n                } else if ((o & 0xF0) == 0xE0) {\n                    end = i + 2;\n                } else if ((o & 0xF8) == 0xF0) {\n                    end = i + 3;\n                } else {\n                    return false;\n                }\n// buggy code\n// \n               if (end > j) {\n                    return false;\n                }\n                while (i < end) {\n                    i++;\n                    o = input[i];\n                    if ((o & 0xC0) != 0x80) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n", "        private static boolean looksLikeUtf8(byte[] input) {\n            int i = 0;\n            if (input.length >= 3 && (input[0] & 0xFF) == 0xEF\n                && (input[1] & 0xFF) == 0xBB & (input[2] & 0xFF) == 0xBF) {\n                i = 3;\n            }\n            int end;\n            for (int j = input.length; i < j; ++i) {\n                int o = input[i];\n                if ((o & 0x80) == 0) {\n                    continue; \n                }\n                if ((o & 0xE0) == 0xC0) {\n                    end = i + 1;\n                } else if ((o & 0xF0) == 0xE0) {\n                    end = i + 2;\n                } else if ((o & 0xF8) == 0xF0) {\n                    end = i + 3;\n                } else {\n                    return false;\n                }\n// buggy code\n// \n               i = end; \n                while (i < end) {\n                    i++;\n                    o = input[i];\n                    if ((o & 0xC0) != 0x80) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n", "        private static boolean looksLikeUtf8(byte[] input) {\n            int i = 0;\n            if (input.length >= 3 && (input[0] & 0xFF) == 0xEF\n                && (input[1] & 0xFF) == 0xBB & (input[2] & 0xFF) == 0xBF) {\n                i = 3;\n            }\n            int end;\n            for (int j = input.length; i < j; ++i) {\n                int o = input[i];\n                if ((o & 0x80) == 0) {\n                    continue; \n                }\n                if ((o & 0xE0) == 0xC0) {\n                    end = i + 1;\n                } else if ((o & 0xF0) == 0xE0) {\n                    end = i + 2;\n                } else if ((o & 0xF8) == 0xF0) {\n                    end = i + 3;\n                } else {\n                    return false;\n                }\n// buggy code\n// \n               if (end >= j) {\n                    return false;\n                }\n                while (i < end) {\n                    i++;\n                    o = input[i];\n                    if ((o & 0xC0) != 0x80) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n", "        private static boolean looksLikeUtf8(byte[] input) {\n            int i = 0;\n            if (input.length >= 3 && (input[0] & 0xFF) == 0xEF\n                && (input[1] & 0xFF) == 0xBB & (input[2] & 0xFF) == 0xBF) {\n                i = 3;\n            }\n            int end;\n            for (int j = input.length; i < j; ++i) {\n                int o = input[i];\n                if ((o & 0x80) == 0) {\n                    continue; \n                }\n                if ((o & 0xE0) == 0xC0) {\n                    end = i + 1;\n                } else if ((o & 0xF0) == 0xE0) {\n                    end = i + 2;\n                } else if ((o & 0xF8) == 0xF0) {\n                    end = i + 3;\n                } else {\n                    return false;\n                }\n// buggy code\n// \n               if (end > j) {\n                    break;\n                }\n                while (i < end) {\n                    i++;\n                    o = input[i];\n                    if ((o & 0xC0) != 0x80) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n", "        private static boolean looksLikeUtf8(byte[] input) {\n            int i = 0;\n            if (input.length >= 3 && (input[0] & 0xFF) == 0xEF\n                && (input[1] & 0xFF) == 0xBB & (input[2] & 0xFF) == 0xBF) {\n                i = 3;\n            }\n            int end;\n            for (int j = input.length; i < j; ++i) {\n                int o = input[i];\n                if ((o & 0x80) == 0) {\n                    continue; \n                }\n                if ((o & 0xE0) == 0xC0) {\n                    end = i + 1;\n                } else if ((o & 0xF0) == 0xE0) {\n                    end = i + 2;\n                } else if ((o & 0xF8) == 0xF0) {\n                    end = i + 3;\n                } else {\n                    return false;\n                }\n// buggy code\n// \n               if (end > input.length)\n                    return false;\n                while (i < end) {\n                    i++;\n                    o = input[i];\n                    if ((o & 0xC0) != 0x80) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n"], "manual_results": [0, 0, 0, 2, 0, 0]}
{"bug_id": "Chart-9", "buggy_code": "    public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n        throws CloneNotSupportedException {\n\n        if (start == null) {\n            throw new IllegalArgumentException(\"Null 'start' argument.\");\n        }\n        if (end == null) {\n            throw new IllegalArgumentException(\"Null 'end' argument.\");\n        }\n        if (start.compareTo(end) > 0) {\n            throw new IllegalArgumentException(\n                    \"Requires start on or before end.\");\n        }\n        boolean emptyRange = false;\n        int startIndex = getIndex(start);\n        if (startIndex < 0) {\n            startIndex = -(startIndex + 1);\n            if (startIndex == this.data.size()) {\n                emptyRange = true;  // start is after last data item\n            }\n        }\n        int endIndex = getIndex(end);\n        if (endIndex < 0) {             // end period is not in original series\n            endIndex = -(endIndex + 1); // this is first item AFTER end period\n            endIndex = endIndex - 1;    // so this is last item BEFORE end\n        }\n        if (endIndex < 0) {\n            emptyRange = true;\n        }\n        if (emptyRange) {\n            TimeSeries copy = (TimeSeries) super.clone();\n            copy.data = new java.util.ArrayList();\n            return copy;\n        }\n        else {\n            return createCopy(startIndex, endIndex);\n        }\n\n    }\n", "fixed_code": "    public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n        throws CloneNotSupportedException {\n        if (start == null) {\n            throw new IllegalArgumentException(\"Null 'start' argument.\");\n        }\n        if (end == null) {\n            throw new IllegalArgumentException(\"Null 'end' argument.\");\n        }\n        if (start.compareTo(end) > 0) {\n            throw new IllegalArgumentException(\n                    \"Requires start on or before end.\");\n        }\n        boolean emptyRange = false;\n        int startIndex = getIndex(start);\n        if (startIndex < 0) {\n            startIndex = -(startIndex + 1);\n            if (startIndex == this.data.size()) {\n                emptyRange = true;  \n            }\n        }\n        int endIndex = getIndex(end);\n        if (endIndex < 0) {             \n            endIndex = -(endIndex + 1); \n            endIndex = endIndex - 1;    \n        }\n        if ((endIndex < 0)  || (endIndex < startIndex)) {\n            emptyRange = true;\n        }\n        if (emptyRange) {\n            TimeSeries copy = (TimeSeries) super.clone();\n            copy.data = new java.util.ArrayList();\n            return copy;\n        }\n        else {\n            return createCopy(startIndex, endIndex);\n        }\n    }\n", "test_results": ["Plausible", "Plausible", "Plausible", "Plausible", "Plausible"], "patches": ["    public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n        throws CloneNotSupportedException {\n        if (start == null) {\n            throw new IllegalArgumentException(\"Null 'start' argument.\");\n        }\n        if (end == null) {\n            throw new IllegalArgumentException(\"Null 'end' argument.\");\n        }\n        if (start.compareTo(end) > 0) {\n            throw new IllegalArgumentException(\n                    \"Requires start on or before end.\");\n        }\n        boolean emptyRange = false;\n        int startIndex = getIndex(start);\n        if (startIndex < 0) {\n            startIndex = -(startIndex + 1);\n            if (startIndex == this.data.size()) {\n                emptyRange = true;  \n            }\n        }\n        int endIndex = getIndex(end);\n        if (endIndex < 0) {             \n            endIndex = -(endIndex + 1); \n            endIndex = endIndex - 1;    \n        }\n// buggy code\n//         if (endIndex < 0) {\n       if (endIndex < startIndex) {\n            emptyRange = true;\n        }\n        if (emptyRange) {\n            TimeSeries copy = (TimeSeries) super.clone();\n            copy.data = new java.util.ArrayList();\n            return copy;\n        }\n        else {\n            return createCopy(startIndex, endIndex);\n        }\n    }\n", "    public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n        throws CloneNotSupportedException {\n        if (start == null) {\n            throw new IllegalArgumentException(\"Null 'start' argument.\");\n        }\n        if (end == null) {\n            throw new IllegalArgumentException(\"Null 'end' argument.\");\n        }\n        if (start.compareTo(end) > 0) {\n            throw new IllegalArgumentException(\n                    \"Requires start on or before end.\");\n        }\n        boolean emptyRange = false;\n        int startIndex = getIndex(start);\n        if (startIndex < 0) {\n            startIndex = -(startIndex + 1);\n            if (startIndex == this.data.size()) {\n                emptyRange = true;  \n            }\n        }\n        int endIndex = getIndex(end);\n        if (endIndex < 0) {             \n            endIndex = -(endIndex + 1); \n            endIndex = endIndex - 1;    \n        }\n// buggy code\n//         if (endIndex < 0) {\n       if (startIndex > endIndex) {\n            emptyRange = true;\n        }\n        if (emptyRange) {\n            TimeSeries copy = (TimeSeries) super.clone();\n            copy.data = new java.util.ArrayList();\n            return copy;\n        }\n        else {\n            return createCopy(startIndex, endIndex);\n        }\n    }\n", "    public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n        throws CloneNotSupportedException {\n        if (start == null) {\n            throw new IllegalArgumentException(\"Null 'start' argument.\");\n        }\n        if (end == null) {\n            throw new IllegalArgumentException(\"Null 'end' argument.\");\n        }\n        if (start.compareTo(end) > 0) {\n            throw new IllegalArgumentException(\n                    \"Requires start on or before end.\");\n        }\n        boolean emptyRange = false;\n        int startIndex = getIndex(start);\n        if (startIndex < 0) {\n            startIndex = -(startIndex + 1);\n            if (startIndex == this.data.size()) {\n                emptyRange = true;  \n            }\n        }\n        int endIndex = getIndex(end);\n        if (endIndex < 0) {             \n            endIndex = -(endIndex + 1); \n            endIndex = endIndex - 1;    \n        }\n// buggy code\n//         if (endIndex < 0) {\n       if (endIndex < 0 || startIndex > endIndex) {\n            emptyRange = true;\n        }\n        if (emptyRange) {\n            TimeSeries copy = (TimeSeries) super.clone();\n            copy.data = new java.util.ArrayList();\n            return copy;\n        }\n        else {\n            return createCopy(startIndex, endIndex);\n        }\n    }\n", "    public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n        throws CloneNotSupportedException {\n        if (start == null) {\n            throw new IllegalArgumentException(\"Null 'start' argument.\");\n        }\n        if (end == null) {\n            throw new IllegalArgumentException(\"Null 'end' argument.\");\n        }\n        if (start.compareTo(end) > 0) {\n            throw new IllegalArgumentException(\n                    \"Requires start on or before end.\");\n        }\n        boolean emptyRange = false;\n        int startIndex = getIndex(start);\n        if (startIndex < 0) {\n            startIndex = -(startIndex + 1);\n            if (startIndex == this.data.size()) {\n                emptyRange = true;  \n            }\n        }\n        int endIndex = getIndex(end);\n        if (endIndex < 0) {             \n            endIndex = -(endIndex + 1); \n            endIndex = endIndex - 1;    \n        }\n// buggy code\n//         if (endIndex < 0) {\n       if ((endIndex < 0) || (startIndex > endIndex)) {\n            emptyRange = true;\n        }\n        if (emptyRange) {\n            TimeSeries copy = (TimeSeries) super.clone();\n            copy.data = new java.util.ArrayList();\n            return copy;\n        }\n        else {\n            return createCopy(startIndex, endIndex);\n        }\n    }\n", "    public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n        throws CloneNotSupportedException {\n        if (start == null) {\n            throw new IllegalArgumentException(\"Null 'start' argument.\");\n        }\n        if (end == null) {\n            throw new IllegalArgumentException(\"Null 'end' argument.\");\n        }\n        if (start.compareTo(end) > 0) {\n            throw new IllegalArgumentException(\n                    \"Requires start on or before end.\");\n        }\n        boolean emptyRange = false;\n        int startIndex = getIndex(start);\n        if (startIndex < 0) {\n            startIndex = -(startIndex + 1);\n            if (startIndex == this.data.size()) {\n                emptyRange = true;  \n            }\n        }\n        int endIndex = getIndex(end);\n        if (endIndex < 0) {             \n            endIndex = -(endIndex + 1); \n            endIndex = endIndex - 1;    \n        }\n// buggy code\n//         if (endIndex < 0) {\n       if (endIndex < 0 || startIndex > endIndex) { \n            emptyRange = true;\n        }\n        if (emptyRange) {\n            TimeSeries copy = (TimeSeries) super.clone();\n            copy.data = new java.util.ArrayList();\n            return copy;\n        }\n        else {\n            return createCopy(startIndex, endIndex);\n        }\n    }\n"], "manual_results": [0, 0, 2, 2, 2]}
{"bug_id": "Lang-17", "buggy_code": "    public final void translate(CharSequence input, Writer out) throws IOException {\n        if (out == null) {\n            throw new IllegalArgumentException(\"The Writer must not be null\");\n        }\n        if (input == null) {\n            return;\n        }\n        int pos = 0;\n        int len = Character.codePointCount(input, 0, input.length());\n        while (pos < len) {\n            int consumed = translate(input, pos, out);\n            if (consumed == 0) {\n                char[] c = Character.toChars(Character.codePointAt(input, pos));\n                out.write(c);\n            }\n            else {\n//          // contract with translators is that they have to understand codepoints \n//          // and they just took care of a surrogate pair\n            for (int pt = 0; pt < consumed; pt++) {\n                    if (pos < len - 2) {\n                pos += Character.charCount(Character.codePointAt(input, pos));\n                    } else {\n                        pos++;\n                    }\n                }\n                pos--;\n            }\n            pos++;\n        }\n    }\n", "fixed_code": "    public final void translate(CharSequence input, Writer out) throws IOException {\n        if (out == null) {\n            throw new IllegalArgumentException(\"The Writer must not be null\");\n        }\n        if (input == null) {\n            return;\n        }\n        int pos = 0;\n        int len = input.length();\n        while (pos < len) {\n            int consumed = translate(input, pos, out);\n            if (consumed == 0) {\n                char[] c = Character.toChars(Character.codePointAt(input, pos));\n                out.write(c);\n                pos+= c.length;\n                continue;\n            }\n            for (int pt = 0; pt < consumed; pt++) {\n                pos += Character.charCount(Character.codePointAt(input, pos));\n            }\n        }\n    }\n", "test_results": ["Plausible"], "patches": ["    public final void translate(CharSequence input, Writer out) throws IOException {\n        if (out == null) {\n            throw new IllegalArgumentException(\"The Writer must not be null\");\n        }\n        if (input == null) {\n            return;\n        }\n        int pos = 0;\n// buggy code\n//         int len = Character.codePointCount(input, 0, input.length());\n//         while (pos < len) {\n//             int consumed = translate(input, pos, out);\n//             if (consumed == 0) {\n//                 char[] c = Character.toChars(Character.codePointAt(input, pos));\n//                 out.write(c);\n//             }\n//             else {\n//             for (int pt = 0; pt < consumed; pt++) {\n//                     if (pos < len - 2) {\n//                 pos += Character.charCount(Character.codePointAt(input, pos));\n//                     } else {\n//                         pos++;\n//                     }\n//                 }\n//                 pos--;\n//             }\n//             pos++;\n       int len = input.length();\n        while (pos < len) {\n            int consumed = translate(input, pos, out);\n            if (consumed == 0) {\n                char[] c = Character.toChars(Character.codePointAt(input, pos));\n                out.write(c);\n            }\n            else {\n            for (int pt = 0; pt < consumed; pt++) {\n                    if (pos < len - 2) {\n                pos += Character.charCount(Character.codePointAt(input, pos));\n                    } else {\n                        pos++;\n                    }\n                }\n                pos--;\n            }\n            pos += Character.charCount(Character.codePointAt(input, pos));\n        }\n    }\n"], "manual_results": [0]}
{"bug_id": "JacksonDatabind-93", "buggy_code": "    public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n    {\n        // There are certain nasty classes that could cause problems, mostly\n        // via default typing -- catch them here.\n        final Class<?> raw = type.getRawClass();\n        String full = raw.getName();\n\n        main_check:\n        do {\n            if (_cfgIllegalClassNames.contains(full)) {\n                break;\n            }\n\n            // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n            //    for some Spring framework types\n            // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n            if (full.startsWith(PREFIX_STRING)) {\n                for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) {\n                    String name = cls.getSimpleName();\n                    // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                    if (\"AbstractPointcutAdvisor\".equals(name)\n                            // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                            || \"AbstractApplicationContext\".equals(name)) {\n                        break main_check;\n                    }\n                }\n            }\n            return;\n        } while (false);\n\n        throw JsonMappingException.from(ctxt,\n                String.format(\"Illegal type (%s) to deserialize: prevented for security reasons\", full));\n    }\n", "fixed_code": "    public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n    {\n        final Class<?> raw = type.getRawClass();\n        String full = raw.getName();\n        main_check:\n        do {\n            if (_cfgIllegalClassNames.contains(full)) {\n                break;\n            }\n            if (!raw.isInterface() && full.startsWith(PREFIX_STRING)) {\n                for (Class<?> cls = raw; (cls != null) && (cls != Object.class); cls = cls.getSuperclass()) {\n                    String name = cls.getSimpleName();\n                    if (\"AbstractPointcutAdvisor\".equals(name)\n                            || \"AbstractApplicationContext\".equals(name)) {\n                        break main_check;\n                    }\n                }\n            }\n            return;\n        } while (false);\n        throw JsonMappingException.from(ctxt,\n                String.format(\"Illegal type (%s) to deserialize: prevented for security reasons\", full));\n    }\n", "test_results": ["Plausible", "Plausible"], "patches": ["    public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n    {\n        final Class<?> raw = type.getRawClass();\n        String full = raw.getName();\n        main_check:\n        do {\n            if (_cfgIllegalClassNames.contains(full)) {\n                break;\n            }\n// buggy code\n//             if (full.startsWith(PREFIX_STRING)) {\n//                 for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) {\n           if (full.startsWith(PREFIX_STRING)) {\n                for (Class<?> cls = raw; cls != null; cls = cls.getSuperclass()) {\n                    String name = cls.getSimpleName();\n                    if (\"AbstractPointcutAdvisor\".equals(name)\n                            || \"AbstractApplicationContext\".equals(name)) {\n                        break main_check;\n                    }\n                }\n            }\n            return;\n        } while (false);\n        throw JsonMappingException.from(ctxt,\n                String.format(\"Illegal type (%s) to deserialize: prevented for security reasons\", full));\n    }\n", "    public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n    {\n        final Class<?> raw = type.getRawClass();\n        String full = raw.getName();\n        main_check:\n        do {\n            if (_cfgIllegalClassNames.contains(full)) {\n                break;\n            }\n// buggy code\n//             if (full.startsWith(PREFIX_STRING)) {\n//                 for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) {\n           for (Class<?> cls = raw; cls != null; cls = cls.getSuperclass()) {\n                if (full.startsWith(PREFIX_STRING)) {\n                    String name = cls.getSimpleName();\n                    if (\"AbstractPointcutAdvisor\".equals(name)\n                            || \"AbstractApplicationContext\".equals(name)) {\n                        break main_check;\n                    }\n                }\n            }\n            return;\n        } while (false);\n        throw JsonMappingException.from(ctxt,\n                String.format(\"Illegal type (%s) to deserialize: prevented for security reasons\", full));\n    }\n"], "manual_results": [0, 0]}
{"bug_id": "Closure-125", "buggy_code": "  private void visitNew(NodeTraversal t, Node n) {\n    Node constructor = n.getFirstChild();\n    JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n    if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n      FunctionType fnType = type.toMaybeFunctionType();\n      if (fnType != null) {\n        visitParameterList(t, n, fnType);\n        ensureTyped(t, n, fnType.getInstanceType());\n      } else {\n        ensureTyped(t, n);\n      }\n    } else {\n      report(t, n, NOT_A_CONSTRUCTOR);\n      ensureTyped(t, n);\n    }\n  }\n", "fixed_code": "  private void visitNew(NodeTraversal t, Node n) {\n    Node constructor = n.getFirstChild();\n    JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n    if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n      FunctionType fnType = type.toMaybeFunctionType();\n      if (fnType != null && fnType.hasInstanceType()) {\n        visitParameterList(t, n, fnType);\n        ensureTyped(t, n, fnType.getInstanceType());\n      } else {\n        ensureTyped(t, n);\n      }\n    } else {\n      report(t, n, NOT_A_CONSTRUCTOR);\n      ensureTyped(t, n);\n    }\n  }\n", "test_results": ["Plausible", "Plausible"], "patches": ["  private void visitNew(NodeTraversal t, Node n) {\n    Node constructor = n.getFirstChild();\n    JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n    if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n      FunctionType fnType = type.toMaybeFunctionType();\n// buggy code\n//       if (fnType != null) {\n     if (fnType != null && fnType.isConstructor()) {\n        visitParameterList(t, n, fnType);\n        ensureTyped(t, n, fnType.getInstanceType());\n      } else {\n        ensureTyped(t, n);\n      }\n    } else {\n      report(t, n, NOT_A_CONSTRUCTOR);\n      ensureTyped(t, n);\n    }\n  }\n", "  private void visitNew(NodeTraversal t, Node n) {\n    Node constructor = n.getFirstChild();\n    JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n    if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n      FunctionType fnType = type.toMaybeFunctionType();\n// buggy code\n//       if (fnType != null) {\n     if (fnType != null && !fnType.isNativeObjectType()) {\n        visitParameterList(t, n, fnType);\n        ensureTyped(t, n, fnType.getInstanceType());\n      } else {\n        ensureTyped(t, n);\n      }\n    } else {\n      report(t, n, NOT_A_CONSTRUCTOR);\n      ensureTyped(t, n);\n    }\n  }\n"], "manual_results": [0, 0]}
{"bug_id": "JacksonDatabind-16", "buggy_code": "    protected final boolean _add(Annotation ann) {\n        if (_annotations == null) {\n            _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n        }\n        Annotation previous = _annotations.put(ann.annotationType(), ann);\n        return (previous != null) && previous.equals(ann);\n    }\n", "fixed_code": "    protected final boolean _add(Annotation ann) {\n        if (_annotations == null) {\n            _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n        }\n        Annotation previous = _annotations.put(ann.annotationType(), ann);\n        return (previous == null) || !previous.equals(ann);\n    }\n", "test_results": ["Plausible", "Plausible", "Plausible", "Plausible"], "patches": ["    protected final boolean _add(Annotation ann) {\n        if (_annotations == null) {\n            _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n        }\n        Annotation previous = _annotations.put(ann.annotationType(), ann);\n// buggy code\n//         return (previous != null) && previous.equals(ann);\n       return (previous == null) || previous.equals(ann);\n    }\n", "    protected final boolean _add(Annotation ann) {\n        if (_annotations == null) {\n            _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n        }\n        Annotation previous = _annotations.put(ann.annotationType(), ann);\n// buggy code\n//         return (previous != null) && previous.equals(ann);\n       return previous == null || previous.equals(ann);\n    }\n", "    protected final boolean _add(Annotation ann) {\n        if (_annotations == null) {\n            _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n        }\n        Annotation previous = _annotations.put(ann.annotationType(), ann);\n// buggy code\n//         return (previous != null) && previous.equals(ann);\n       return ((previous == null) || previous.equals(ann));\n    }\n", "    protected final boolean _add(Annotation ann) {\n        if (_annotations == null) {\n            _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n        }\n        Annotation previous = _annotations.put(ann.annotationType(), ann);\n// buggy code\n//         return (previous != null) && previous.equals(ann);\n       return (previous != null) && previous.equals(ann) || previous == null;\n    }\n"], "manual_results": [0, 0, 0, 0]}
{"bug_id": "Gson-10", "buggy_code": "  private ReflectiveTypeAdapterFactory.BoundField createBoundField(\n      final Gson context, final Field field, final String name,\n      final TypeToken<?> fieldType, boolean serialize, boolean deserialize) {\n    final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\n    // special casing primitives here saves ~5% on Android...\n    JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\n    TypeAdapter<?> mapped = null;\n    if (annotation != null) {\n      mapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation);\n    }\n    final boolean jsonAdapterPresent = mapped != null;\n    if (mapped == null) mapped = context.getAdapter(fieldType);\n\n    final TypeAdapter<?> typeAdapter = mapped;\n    return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n      @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n      @Override void write(JsonWriter writer, Object value)\n          throws IOException, IllegalAccessException {\n        Object fieldValue = field.get(value);\n        TypeAdapter t =\n          new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n        t.write(writer, fieldValue);\n      }\n      @Override void read(JsonReader reader, Object value)\n          throws IOException, IllegalAccessException {\n        Object fieldValue = typeAdapter.read(reader);\n        if (fieldValue != null || !isPrimitive) {\n          field.set(value, fieldValue);\n        }\n      }\n      @Override public boolean writeField(Object value) throws IOException, IllegalAccessException {\n        if (!serialized) return false;\n        Object fieldValue = field.get(value);\n        return fieldValue != value; // avoid recursion for example for Throwable.cause\n      }\n    };\n  }\n", "fixed_code": "  private ReflectiveTypeAdapterFactory.BoundField createBoundField(\n      final Gson context, final Field field, final String name,\n      final TypeToken<?> fieldType, boolean serialize, boolean deserialize) {\n    final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\n    JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\n    TypeAdapter<?> mapped = null;\n    if (annotation != null) {\n      mapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation);\n    }\n    final boolean jsonAdapterPresent = mapped != null;\n    if (mapped == null) mapped = context.getAdapter(fieldType);\n    final TypeAdapter<?> typeAdapter = mapped;\n    return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n      @SuppressWarnings({\"unchecked\", \"rawtypes\"}) \n      @Override void write(JsonWriter writer, Object value)\n          throws IOException, IllegalAccessException {\n        Object fieldValue = field.get(value);\n        TypeAdapter t = jsonAdapterPresent ? typeAdapter\n            : new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n        t.write(writer, fieldValue);\n      }\n      @Override void read(JsonReader reader, Object value)\n          throws IOException, IllegalAccessException {\n        Object fieldValue = typeAdapter.read(reader);\n        if (fieldValue != null || !isPrimitive) {\n          field.set(value, fieldValue);\n        }\n      }\n      @Override public boolean writeField(Object value) throws IOException, IllegalAccessException {\n        if (!serialized) return false;\n        Object fieldValue = field.get(value);\n        return fieldValue != value; \n      }\n    };\n  }\n", "test_results": ["Plausible", "Plausible"], "patches": ["  private ReflectiveTypeAdapterFactory.BoundField createBoundField(\n      final Gson context, final Field field, final String name,\n      final TypeToken<?> fieldType, boolean serialize, boolean deserialize) {\n    final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\n    JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\n    TypeAdapter<?> mapped = null;\n    if (annotation != null) {\n      mapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation);\n    }\n    final boolean jsonAdapterPresent = mapped != null;\n    if (mapped == null) mapped = context.getAdapter(fieldType);\n    final TypeAdapter<?> typeAdapter = mapped;\n    return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n      @SuppressWarnings({\"unchecked\", \"rawtypes\"}) \n      @Override void write(JsonWriter writer, Object value)\n          throws IOException, IllegalAccessException {\n        Object fieldValue = field.get(value);\n// buggy code\n//         TypeAdapter t =\n//           new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n       TypeAdapter t = typeAdapter;\n        if (!jsonAdapterPresent) {\n          t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n        }\n        t.write(writer, fieldValue);\n      }\n      @Override void read(JsonReader reader, Object value)\n          throws IOException, IllegalAccessException {\n        Object fieldValue = typeAdapter.read(reader);\n        if (fieldValue != null || !isPrimitive) {\n          field.set(value, fieldValue);\n        }\n      }\n      @Override public boolean writeField(Object value) throws IOException, IllegalAccessException {\n        if (!serialized) return false;\n        Object fieldValue = field.get(value);\n        return fieldValue != value; \n      }\n    };\n  }\n", "  private ReflectiveTypeAdapterFactory.BoundField createBoundField(\n      final Gson context, final Field field, final String name,\n      final TypeToken<?> fieldType, boolean serialize, boolean deserialize) {\n    final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\n    JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\n    TypeAdapter<?> mapped = null;\n    if (annotation != null) {\n      mapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation);\n    }\n    final boolean jsonAdapterPresent = mapped != null;\n    if (mapped == null) mapped = context.getAdapter(fieldType);\n    final TypeAdapter<?> typeAdapter = mapped;\n    return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n      @SuppressWarnings({\"unchecked\", \"rawtypes\"}) \n      @Override void write(JsonWriter writer, Object value)\n          throws IOException, IllegalAccessException {\n        Object fieldValue = field.get(value);\n// buggy code\n//         TypeAdapter t =\n//           new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n       TypeAdapter t = typeAdapter;\n        if (!jsonAdapterPresent) {\n          t = new TypeAdapterRuntimeTypeWrapper(context, t, fieldType.getType());\n        }\n        t.write(writer, fieldValue);\n      }\n      @Override void read(JsonReader reader, Object value)\n          throws IOException, IllegalAccessException {\n        Object fieldValue = typeAdapter.read(reader);\n        if (fieldValue != null || !isPrimitive) {\n          field.set(value, fieldValue);\n        }\n      }\n      @Override public boolean writeField(Object value) throws IOException, IllegalAccessException {\n        if (!serialized) return false;\n        Object fieldValue = field.get(value);\n        return fieldValue != value; \n      }\n    };\n  }\n"], "manual_results": [0, 2]}
{"bug_id": "Math-91", "buggy_code": "    public int compareTo(Fraction object) {\n        double nOd = doubleValue();\n        double dOn = object.doubleValue();\n        return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n    }\n", "fixed_code": "    public int compareTo(Fraction object) {\n        long nOd = ((long) numerator) * object.denominator;\n        long dOn = ((long) denominator) * object.numerator;\n        return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n    }\n", "test_results": ["Plausible"], "patches": ["    public int compareTo(Fraction object) {\n// buggy code\n//         double nOd = doubleValue();\n//         double dOn = object.doubleValue();\n       double nOd = numerator * object.denominator;\n        double dOn = denominator * object.numerator;\n        return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n    }\n"], "manual_results": [2]}
{"bug_id": "Cli-11", "buggy_code": "    private static void appendOption(final StringBuffer buff, \n                                     final Option option, \n                                     final boolean required)\n    {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n\n        // if the Option has a value\n        if (option.hasArg() && (option.getArgName() != null))\n        {\n            buff.append(\" <\").append(option.getArgName()).append(\">\");\n        }\n\n        // if the Option is not a required option\n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }\n", "fixed_code": "    private static void appendOption(final StringBuffer buff, \n                                     final Option option, \n                                     final boolean required)\n    {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n        if (option.hasArg() && option.hasArgName())\n        {\n            buff.append(\" <\").append(option.getArgName()).append(\">\");\n        }\n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }\n", "test_results": ["Plausible"], "patches": ["    private static void appendOption(final StringBuffer buff, \n                                     final Option option, \n                                     final boolean required)\n    {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n// buggy code\n//         if (option.hasArg() && (option.getArgName() != null))\n       if (option.hasArg() && (option.getArgName() != null) && !option.isRequired())\n        {\n            buff.append(\" <\").append(option.getArgName()).append(\">\");\n        }\n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }\n"], "manual_results": [0]}
{"bug_id": "JacksonDatabind-96", "buggy_code": "    protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n            BeanDescription beanDesc, CreatorCollector creators,\n            CreatorCandidate candidate)\n        throws JsonMappingException\n    {\n        // Looks like there's bit of magic regarding 1-parameter creators; others simpler:\n        if (1 != candidate.paramCount()) {\n            // Ok: for delegates, we want one and exactly one parameter without\n            // injection AND without name\n            int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n            if (oneNotInjected >= 0) {\n                // getting close; but most not have name\n                if (candidate.paramName(oneNotInjected) == null) {\n                    _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                    return;\n                }\n            }\n            _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n            return;\n        }\n        AnnotatedParameter param = candidate.parameter(0);\n        JacksonInject.Value injectId = candidate.injection(0);\n        PropertyName paramName = candidate.explicitParamName(0);\n        BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n\n        // If there's injection or explicit name, should be properties-based\n        boolean useProps = (paramName != null) || (injectId != null);\n        if (!useProps && (paramDef != null)) {\n            // One more thing: if implicit name matches property with a getter\n            // or field, we'll consider it property-based as well\n\n            // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n            //    not implicit name, but name with possible strategy-based-rename\n//            paramName = candidate.findImplicitParamName(0);\n            paramName = candidate.findImplicitParamName(0);\n            useProps = (paramName != null) && paramDef.couldSerialize();\n        }\n        if (useProps) {\n            SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                    constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n            };\n            creators.addPropertyCreator(candidate.creator(), true, properties);\n            return;\n        }\n        _handleSingleArgumentCreator(creators, candidate.creator(), true, true);\n\n        // one more thing: sever link to creator property, to avoid possible later\n        // problems with \"unresolved\" constructor property\n        if (paramDef != null) {\n            ((POJOPropertyBuilder) paramDef).removeConstructors();\n        }\n    }\n", "fixed_code": "    protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n            BeanDescription beanDesc, CreatorCollector creators,\n            CreatorCandidate candidate)\n        throws JsonMappingException\n    {\n        if (1 != candidate.paramCount()) {\n            int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n            if (oneNotInjected >= 0) {\n                if (candidate.paramName(oneNotInjected) == null) {\n                    _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                    return;\n                }\n            }\n            _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n            return;\n        }\n        AnnotatedParameter param = candidate.parameter(0);\n        JacksonInject.Value injectId = candidate.injection(0);\n        PropertyName paramName = candidate.explicitParamName(0);\n        BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n        boolean useProps = (paramName != null) || (injectId != null);\n        if (!useProps && (paramDef != null)) {\n            paramName = candidate.paramName(0);\n            useProps = (paramName != null) && paramDef.couldSerialize();\n        }\n        if (useProps) {\n            SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                    constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n            };\n            creators.addPropertyCreator(candidate.creator(), true, properties);\n            return;\n        }\n        _handleSingleArgumentCreator(creators, candidate.creator(), true, true);\n        if (paramDef != null) {\n            ((POJOPropertyBuilder) paramDef).removeConstructors();\n        }\n    }\n", "test_results": ["Plausible"], "patches": ["    protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n            BeanDescription beanDesc, CreatorCollector creators,\n            CreatorCandidate candidate)\n        throws JsonMappingException\n    {\n        if (1 != candidate.paramCount()) {\n            int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n            if (oneNotInjected >= 0) {\n                if (candidate.paramName(oneNotInjected) == null) {\n                    _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                    return;\n                }\n            }\n            _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n            return;\n        }\n        AnnotatedParameter param = candidate.parameter(0);\n        JacksonInject.Value injectId = candidate.injection(0);\n        PropertyName paramName = candidate.explicitParamName(0);\n        BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n        boolean useProps = (paramName != null) || (injectId != null);\n        if (!useProps && (paramDef != null)) {\n// buggy code\n//             paramName = candidate.findImplicitParamName(0);\n           paramName = paramDef.getFullName();\n            useProps = (paramName != null) && paramDef.couldSerialize();\n        }\n        if (useProps) {\n            SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                    constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n            };\n            creators.addPropertyCreator(candidate.creator(), true, properties);\n            return;\n        }\n        _handleSingleArgumentCreator(creators, candidate.creator(), true, true);\n        if (paramDef != null) {\n            ((POJOPropertyBuilder) paramDef).removeConstructors();\n        }\n    }\n"], "manual_results": [0]}
{"bug_id": "Math-101", "buggy_code": "    public Complex parse(String source, ParsePosition pos) {\n        int initialIndex = pos.getIndex();\n\n        // parse whitespace\n        parseAndIgnoreWhitespace(source, pos);\n\n        // parse real\n        Number re = parseNumber(source, getRealFormat(), pos);\n        if (re == null) {\n            // invalid real number\n            // set index back to initial, error index should already be set\n            // character examined.\n            pos.setIndex(initialIndex);\n            return null;\n        }\n\n        // parse sign\n        int startIndex = pos.getIndex();\n        char c = parseNextCharacter(source, pos);\n        int sign = 0;\n        switch (c) {\n        case 0 :\n            // no sign\n            // return real only complex number\n            return new Complex(re.doubleValue(), 0.0);\n        case '-' :\n            sign = -1;\n            break;\n        case '+' :\n            sign = 1;\n            break;\n        default :\n            // invalid sign\n            // set index back to initial, error index should be the last\n            // character examined.\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n        }\n\n        // parse whitespace\n        parseAndIgnoreWhitespace(source, pos);\n\n        // parse imaginary\n        Number im = parseNumber(source, getRealFormat(), pos);\n        if (im == null) {\n            // invalid imaginary number\n            // set index back to initial, error index should already be set\n            // character examined.\n            pos.setIndex(initialIndex);\n            return null;\n        }\n\n        // parse imaginary character\n        int n = getImaginaryCharacter().length();\n        startIndex = pos.getIndex();\n        int endIndex = startIndex + n;\n        if (\n            source.substring(startIndex, endIndex).compareTo(\n            getImaginaryCharacter()) != 0) {\n            // set index back to initial, error index should be the start index\n            // character examined.\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n        }\n        pos.setIndex(endIndex);\n\n        return new Complex(re.doubleValue(), im.doubleValue() * sign);\n    }\n", "fixed_code": "    public Complex parse(String source, ParsePosition pos) {\n        int initialIndex = pos.getIndex();\n        parseAndIgnoreWhitespace(source, pos);\n        Number re = parseNumber(source, getRealFormat(), pos);\n        if (re == null) {\n            pos.setIndex(initialIndex);\n            return null;\n        }\n        int startIndex = pos.getIndex();\n        char c = parseNextCharacter(source, pos);\n        int sign = 0;\n        switch (c) {\n        case 0 :\n            return new Complex(re.doubleValue(), 0.0);\n        case '-' :\n            sign = -1;\n            break;\n        case '+' :\n            sign = 1;\n            break;\n        default :\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n        }\n        parseAndIgnoreWhitespace(source, pos);\n        Number im = parseNumber(source, getRealFormat(), pos);\n        if (im == null) {\n            pos.setIndex(initialIndex);\n            return null;\n        }\n        int n = getImaginaryCharacter().length();\n        startIndex = pos.getIndex();\n        int endIndex = startIndex + n;\n        if ((startIndex >= source.length()) ||\n            (endIndex > source.length()) ||\n            source.substring(startIndex, endIndex).compareTo(\n            getImaginaryCharacter()) != 0) {\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n        }\n        pos.setIndex(endIndex);\n        return new Complex(re.doubleValue(), im.doubleValue() * sign);\n    }\n", "test_results": ["Plausible", "Plausible", "Plausible"], "patches": ["    public Complex parse(String source, ParsePosition pos) {\n        int initialIndex = pos.getIndex();\n        parseAndIgnoreWhitespace(source, pos);\n        Number re = parseNumber(source, getRealFormat(), pos);\n        if (re == null) {\n            pos.setIndex(initialIndex);\n            return null;\n        }\n        int startIndex = pos.getIndex();\n        char c = parseNextCharacter(source, pos);\n        int sign = 0;\n        switch (c) {\n        case 0 :\n            return new Complex(re.doubleValue(), 0.0);\n        case '-' :\n            sign = -1;\n            break;\n        case '+' :\n            sign = 1;\n            break;\n        default :\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n        }\n        parseAndIgnoreWhitespace(source, pos);\n        Number im = parseNumber(source, getRealFormat(), pos);\n        if (im == null) {\n            pos.setIndex(initialIndex);\n            return null;\n        }\n        int n = getImaginaryCharacter().length();\n        startIndex = pos.getIndex();\n        int endIndex = startIndex + n;\n// buggy code\n//         if (\n       if (endIndex > source.length() ||\n            source.substring(startIndex, endIndex).compareTo(\n            getImaginaryCharacter()) != 0) {\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n        }\n        pos.setIndex(endIndex);\n        return new Complex(re.doubleValue(), im.doubleValue() * sign);\n    }\n", "    public Complex parse(String source, ParsePosition pos) {\n        int initialIndex = pos.getIndex();\n        parseAndIgnoreWhitespace(source, pos);\n        Number re = parseNumber(source, getRealFormat(), pos);\n        if (re == null) {\n            pos.setIndex(initialIndex);\n            return null;\n        }\n        int startIndex = pos.getIndex();\n        char c = parseNextCharacter(source, pos);\n        int sign = 0;\n        switch (c) {\n        case 0 :\n            return new Complex(re.doubleValue(), 0.0);\n        case '-' :\n            sign = -1;\n            break;\n        case '+' :\n            sign = 1;\n            break;\n        default :\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n        }\n        parseAndIgnoreWhitespace(source, pos);\n        Number im = parseNumber(source, getRealFormat(), pos);\n        if (im == null) {\n            pos.setIndex(initialIndex);\n            return null;\n        }\n        int n = getImaginaryCharacter().length();\n        startIndex = pos.getIndex();\n        int endIndex = startIndex + n;\n// buggy code\n//         if (\n       if (source.length() < endIndex ||\n            source.substring(startIndex, endIndex).compareTo(\n            getImaginaryCharacter()) != 0) {\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n        }\n        pos.setIndex(endIndex);\n        return new Complex(re.doubleValue(), im.doubleValue() * sign);\n    }\n", "    public Complex parse(String source, ParsePosition pos) {\n        int initialIndex = pos.getIndex();\n        parseAndIgnoreWhitespace(source, pos);\n        Number re = parseNumber(source, getRealFormat(), pos);\n        if (re == null) {\n            pos.setIndex(initialIndex);\n            return null;\n        }\n        int startIndex = pos.getIndex();\n        char c = parseNextCharacter(source, pos);\n        int sign = 0;\n        switch (c) {\n        case 0 :\n            return new Complex(re.doubleValue(), 0.0);\n        case '-' :\n            sign = -1;\n            break;\n        case '+' :\n            sign = 1;\n            break;\n        default :\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n        }\n        parseAndIgnoreWhitespace(source, pos);\n        Number im = parseNumber(source, getRealFormat(), pos);\n        if (im == null) {\n            pos.setIndex(initialIndex);\n            return null;\n        }\n        int n = getImaginaryCharacter().length();\n        startIndex = pos.getIndex();\n        int endIndex = startIndex + n;\n// buggy code\n//         if (\n       if (endIndex > source.length() || \n            source.substring(startIndex, endIndex).compareTo(\n            getImaginaryCharacter()) != 0) {\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n        }\n        pos.setIndex(endIndex);\n        return new Complex(re.doubleValue(), im.doubleValue() * sign);\n    }\n"], "manual_results": [0, 0, 0]}
{"bug_id": "Cli-9", "buggy_code": "    protected void checkRequiredOptions()\n        throws MissingOptionException\n    {\n        // if there are required options that have not been\n        // processsed\n        if (getRequiredOptions().size() > 0)\n        {\n            Iterator iter = getRequiredOptions().iterator();\n            StringBuffer buff = new StringBuffer(\"Missing required option\");\n            buff.append(getRequiredOptions().size() == 1 ? \"\" : \"s\");\n            buff.append(\": \");\n\n\n            // loop through the required options\n            while (iter.hasNext())\n            {\n                buff.append(iter.next());\n            }\n\n            throw new MissingOptionException(buff.toString());\n        }\n    }\n", "fixed_code": "    protected void checkRequiredOptions()\n        throws MissingOptionException\n    {\n        if (getRequiredOptions().size() > 0)\n        {\n            Iterator iter = getRequiredOptions().iterator();\n            StringBuffer buff = new StringBuffer(\"Missing required option\");\n            buff.append(getRequiredOptions().size() == 1 ? \"\" : \"s\");\n            buff.append(\": \");\n            while (iter.hasNext())\n            {\n                buff.append(iter.next());\n                buff.append(\", \");\n            }\n            throw new MissingOptionException(buff.substring(0, buff.length() - 2));\n        }\n    }\n", "test_results": ["Plausible", "Plausible", "Plausible", "Plausible", "Plausible", "Plausible"], "patches": ["    protected void checkRequiredOptions()\n        throws MissingOptionException\n    {\n        if (getRequiredOptions().size() > 0)\n        {\n            Iterator iter = getRequiredOptions().iterator();\n            StringBuffer buff = new StringBuffer(\"Missing required option\");\n            buff.append(getRequiredOptions().size() == 1 ? \"\" : \"s\");\n            buff.append(\": \");\n            while (iter.hasNext())\n            {\n                buff.append(iter.next());\n// buggy code\n//             }\n//             throw new MissingOptionException(buff.toString());\n               if (iter.hasNext())\n                {\n                    buff.append(\", \");\n                }\n            }\n            throw new MissingOptionException(buff.toString());\n        }\n    }\n", "    protected void checkRequiredOptions()\n        throws MissingOptionException\n    {\n        if (getRequiredOptions().size() > 0)\n        {\n            Iterator iter = getRequiredOptions().iterator();\n            StringBuffer buff = new StringBuffer(\"Missing required option\");\n            buff.append(getRequiredOptions().size() == 1 ? \"\" : \"s\");\n            buff.append(\": \");\n            while (iter.hasNext())\n            {\n                buff.append(iter.next());\n// buggy code\n//             }\n//             throw new MissingOptionException(buff.toString());\n               if (iter.hasNext())\n                {\n                    buff.append(\", \");\n                }\n            }\n            throw new MissingOptionException(buff.toString());\n        }\n        else\n        {\n            return;\n        }\n    }\n", "    protected void checkRequiredOptions()\n        throws MissingOptionException\n    {\n        if (getRequiredOptions().size() > 0)\n        {\n            Iterator iter = getRequiredOptions().iterator();\n            StringBuffer buff = new StringBuffer(\"Missing required option\");\n            buff.append(getRequiredOptions().size() == 1 ? \"\" : \"s\");\n            buff.append(\": \");\n            while (iter.hasNext())\n            {\n                buff.append(iter.next());\n// buggy code\n//             }\n//             throw new MissingOptionException(buff.toString());\n               if (iter.hasNext())\n                    buff.append(\", \");\n            }\n            throw new MissingOptionException(buff.toString());\n        }\n    }\n", "    protected void checkRequiredOptions()\n        throws MissingOptionException\n    {\n        if (getRequiredOptions().size() > 0)\n        {\n            Iterator iter = getRequiredOptions().iterator();\n            StringBuffer buff = new StringBuffer(\"Missing required option\");\n            buff.append(getRequiredOptions().size() == 1 ? \"\" : \"s\");\n            buff.append(\": \");\n            while (iter.hasNext())\n            {\n                buff.append(iter.next());\n// buggy code\n//             }\n//             throw new MissingOptionException(buff.toString());\n               if (iter.hasNext())\n                {\n                    buff.append(\", \");\n                }\n            }\n            throw new MissingOptionException(buff.toString());\n        }\n        else\n        {\n        }\n    }\n", "    protected void checkRequiredOptions()\n        throws MissingOptionException\n    {\n        if (getRequiredOptions().size() > 0)\n        {\n            Iterator iter = getRequiredOptions().iterator();\n            StringBuffer buff = new StringBuffer(\"Missing required option\");\n            buff.append(getRequiredOptions().size() == 1 ? \"\" : \"s\");\n            buff.append(\": \");\n            while (iter.hasNext())\n            {\n                buff.append(iter.next());\n// buggy code\n//             }\n//             throw new MissingOptionException(buff.toString());\n               if (iter.hasNext()) {\n                    buff.append(\", \");\n                }\n            }\n            throw new MissingOptionException(buff.toString());\n        }\n    }\n", "    protected void checkRequiredOptions()\n        throws MissingOptionException\n    {\n        if (getRequiredOptions().size() > 0)\n        {\n            Iterator iter = getRequiredOptions().iterator();\n            StringBuffer buff = new StringBuffer(\"Missing required option\");\n            buff.append(getRequiredOptions().size() == 1 ? \"\" : \"s\");\n            buff.append(\": \");\n            while (iter.hasNext())\n            {\n                buff.append(iter.next());\n// buggy code\n//             }\n//             throw new MissingOptionException(buff.toString());\n               if (iter.hasNext())\n                {\n                    buff.append(\", \");\n                }\n            }\n            throw new MissingOptionException(buff.toString());\n        }\n        else if (getRequiredOptions().size() < 0)\n        {\n            throw new MissingOptionException(\"Missing required options\");\n        }\n    }\n"], "manual_results": [0, 0, 0, 0, 0, 0]}
{"bug_id": "Lang-22", "buggy_code": "    private static int greatestCommonDivisor(int u, int v) {\n        // From Commons Math:\n        //if either operand is abs 1, return 1:\n        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n            return 1;\n        }\n        // keep u and v negative, as negative integers range down to\n        // -2^31, while positive numbers can only be as large as 2^31-1\n        // (i.e. we can't necessarily negate a negative number without\n        // overflow)\n        if (u>0) { u=-u; } // make u negative\n        if (v>0) { v=-v; } // make v negative\n        // B1. [Find power of 2]\n        int k=0;\n        while ((u&1)==0 && (v&1)==0 && k<31) { // while u and v are both even...\n            u/=2; v/=2; k++; // cast out twos.\n        }\n        if (k==31) {\n            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n        }\n        // B2. Initialize: u and v have been divided by 2^k and at least\n        //     one is odd.\n        int t = ((u&1)==1) ? v : -(u/2)/*B3*/;\n        // t negative: u was odd, v may be even (t replaces v)\n        // t positive: u was even, v is odd (t replaces u)\n        do {\n            /* assert u<0 && v<0; */\n            // B4/B3: cast out twos from t.\n            while ((t&1)==0) { // while t is even..\n                t/=2; // cast out twos\n            }\n            // B5 [reset max(u,v)]\n            if (t>0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n            // B6/B3. at this point both u and v should be odd.\n            t = (v - u)/2;\n            // |u| larger: t positive (replace u)\n            // |v| larger: t negative (replace v)\n        } while (t!=0);\n        return -u*(1<<k); // gcd is u*2^k\n    }\n", "fixed_code": "    private static int greatestCommonDivisor(int u, int v) {\n        if ((u == 0) || (v == 0)) {\n            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {\n                throw new ArithmeticException(\"overflow: gcd is 2^31\");\n            }\n            return Math.abs(u) + Math.abs(v);\n        }\n        if (Math.abs(u) == 1 || Math.abs(v) == 1) {\n            return 1;\n        }\n        if (u>0) { u=-u; } \n        if (v>0) { v=-v; } \n        int k=0;\n        while ((u&1)==0 && (v&1)==0 && k<31) { \n            u/=2; v/=2; k++; \n        }\n        if (k==31) {\n            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n        }\n        int t = ((u&1)==1) ? v : -(u/2);\n        do {\n            while ((t&1)==0) { \n                t/=2; \n            }\n            if (t>0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n            t = (v - u)/2;\n        } while (t!=0);\n        return -u*(1<<k); \n    }\n", "test_results": ["Plausible", "Plausible", "Plausible"], "patches": ["    private static int greatestCommonDivisor(int u, int v) {\n// buggy code\n//         if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n       if (Math.abs(u) <= 1 && Math.abs(v) <= 1) {\n            return 1;\n        }\n        if (u>0) { u=-u; } \n        if (v>0) { v=-v; } \n        int k=0;\n        while ((u&1)==0 && (v&1)==0 && k<31) { \n            u/=2; v/=2; k++; \n        }\n        if (k==31) {\n            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n        }\n        int t = ((u&1)==1) ? v : -(u/2);\n        do {\n            while ((t&1)==0) { \n                t/=2; \n            }\n            if (t>0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n            t = (v - u)/2;\n        } while (t!=0);\n        return -u*(1<<k); \n    }\n", "    private static int greatestCommonDivisor(int u, int v) {\n// buggy code\n//         if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n       if (u==0 || v==0) {\n            return 1;\n        }\n        if (u>0) { u=-u; } \n        if (v>0) { v=-v; } \n        int k=0;\n        while ((u&1)==0 && (v&1)==0 && k<31) { \n            u/=2; v/=2; k++; \n        }\n        if (k==31) {\n            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n        }\n        int t = ((u&1)==1) ? v : -(u/2);\n        do {\n            while ((t&1)==0) { \n                t/=2; \n            }\n            if (t>0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n            t = (v - u)/2;\n        } while (t!=0);\n        return -u*(1<<k); \n    }\n", "    private static int greatestCommonDivisor(int u, int v) {\n// buggy code\n//         if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n       if (Math.abs(u) == 1 || Math.abs(v) == 1) {\n            return 1;\n        }\n        if (u>0) { u=-u; } \n        if (v>0) { v=-v; } \n        int k=0;\n        while ((u&1)==0 && (v&1)==0 && k<31) { \n            u/=2; v/=2; k++; \n        }\n        if (k==31) {\n            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n        }\n        int t = ((u&1)==1) ? v : -(u/2);\n        do {\n            while ((t&1)==0) { \n                t/=2; \n            }\n            if (t>0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n            t = (v - u)/2;\n        } while (t!=0);\n        return -u*(1<<k); \n    }\n"], "manual_results": [0, 0, 0]}
{"bug_id": "Mockito-38", "buggy_code": "    private boolean toStringEquals(Matcher m, Object arg) {\n        return StringDescription.toString(m).equals(arg.toString());\n    }\n", "fixed_code": "    private boolean toStringEquals(Matcher m, Object arg) {\n        return StringDescription.toString(m).equals(arg == null? \"null\" : arg.toString());\n    }\n", "test_results": ["Plausible", "Plausible"], "patches": ["    private boolean toStringEquals(Matcher m, Object arg) {\n// buggy code\n//         return StringDescription.toString(m).equals(arg.toString());\n       return StringDescription.toString(m).equals(String.valueOf(arg));\n    }\n", "    private boolean toStringEquals(Matcher m, Object arg) {\n// buggy code\n//         return StringDescription.toString(m).equals(arg.toString());\n       try {\n            return StringDescription.toString(m).equals(arg.toString());\n        } catch (Exception e) {\n            return false;\n        }\n    }\n"], "manual_results": [0, 0]}
{"bug_id": "Cli-37", "buggy_code": "    private boolean isShortOption(String token)\n    {\n        // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n        return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n\n        // remove leading \"-\" and \"=value\"\n    }\n", "fixed_code": "    private boolean isShortOption(String token)\n    {\n        if (!token.startsWith(\"-\") || token.length() == 1)\n        {\n            return false;\n        }\n        int pos = token.indexOf(\"=\");\n        String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n        return options.hasShortOption(optName);\n    }\n", "test_results": ["Plausible"], "patches": ["    private boolean isShortOption(String token)\n    {\n// buggy code\n//         return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n       return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1));\n    }\n"], "manual_results": [0]}
{"bug_id": "Lang-18", "buggy_code": "    protected List<Rule> parsePattern() {\n        DateFormatSymbols symbols = new DateFormatSymbols(mLocale);\n        List<Rule> rules = new ArrayList<Rule>();\n\n        String[] ERAs = symbols.getEras();\n        String[] months = symbols.getMonths();\n        String[] shortMonths = symbols.getShortMonths();\n        String[] weekdays = symbols.getWeekdays();\n        String[] shortWeekdays = symbols.getShortWeekdays();\n        String[] AmPmStrings = symbols.getAmPmStrings();\n\n        int length = mPattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i = 0; i < length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(mPattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n\n            Rule rule;\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                rule = new TextField(Calendar.ERA, ERAs);\n                break;\n            case 'y': // year (number)\n                if (tokenLen >= 4) {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                } else {\n                    rule = TwoDigitYearField.INSTANCE;\n                }\n                break;\n            case 'M': // month in year (text and number)\n                if (tokenLen >= 4) {\n                    rule = new TextField(Calendar.MONTH, months);\n                } else if (tokenLen == 3) {\n                    rule = new TextField(Calendar.MONTH, shortMonths);\n                } else if (tokenLen == 2) {\n                    rule = TwoDigitMonthField.INSTANCE;\n                } else {\n                    rule = UnpaddedMonthField.INSTANCE;\n                }\n                break;\n            case 'd': // day in month (number)\n                rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);\n                break;\n            case 'h': // hour in am/pm (number, 1..12)\n                rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));\n                break;\n            case 'H': // hour in day (number, 0..23)\n                rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);\n                break;\n            case 'm': // minute in hour (number)\n                rule = selectNumberRule(Calendar.MINUTE, tokenLen);\n                break;\n            case 's': // second in minute (number)\n                rule = selectNumberRule(Calendar.SECOND, tokenLen);\n                break;\n            case 'S': // millisecond (number)\n                rule = selectNumberRule(Calendar.MILLISECOND, tokenLen);\n                break;\n            case 'E': // day in week (text)\n                rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);\n                break;\n            case 'D': // day in year (number)\n                rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);\n                break;\n            case 'F': // day of week in month (number)\n                rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);\n                break;\n            case 'w': // week in year (number)\n                rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);\n                break;\n            case 'W': // week in month (number)\n                rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                rule = new TextField(Calendar.AM_PM, AmPmStrings);\n                break;\n            case 'k': // hour in day (1..24)\n                rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));\n                break;\n            case 'K': // hour in am/pm (0..11)\n                rule = selectNumberRule(Calendar.HOUR, tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG);\n                } else {\n                    rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT);\n                }\n                break;\n            case 'Z': // time zone (value)\n                if (tokenLen == 1) {\n                    rule = TimeZoneNumberRule.INSTANCE_NO_COLON;\n                } else {\n                    rule = TimeZoneNumberRule.INSTANCE_COLON;\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    rule = new CharacterLiteral(sub.charAt(0));\n                } else {\n                    rule = new StringLiteral(sub);\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n            }\n\n            rules.add(rule);\n        }\n\n        return rules;\n    }\n", "fixed_code": "    protected List<Rule> parsePattern() {\n        DateFormatSymbols symbols = new DateFormatSymbols(mLocale);\n        List<Rule> rules = new ArrayList<Rule>();\n        String[] ERAs = symbols.getEras();\n        String[] months = symbols.getMonths();\n        String[] shortMonths = symbols.getShortMonths();\n        String[] weekdays = symbols.getWeekdays();\n        String[] shortWeekdays = symbols.getShortWeekdays();\n        String[] AmPmStrings = symbols.getAmPmStrings();\n        int length = mPattern.length();\n        int[] indexRef = new int[1];\n        for (int i = 0; i < length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(mPattern, indexRef);\n            i = indexRef[0];\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            Rule rule;\n            char c = token.charAt(0);\n            switch (c) {\n            case 'G': \n                rule = new TextField(Calendar.ERA, ERAs);\n                break;\n            case 'y': \n                if (tokenLen == 2) {\n                    rule = TwoDigitYearField.INSTANCE;\n                } else {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen);\n                }\n                break;\n            case 'M': \n                if (tokenLen >= 4) {\n                    rule = new TextField(Calendar.MONTH, months);\n                } else if (tokenLen == 3) {\n                    rule = new TextField(Calendar.MONTH, shortMonths);\n                } else if (tokenLen == 2) {\n                    rule = TwoDigitMonthField.INSTANCE;\n                } else {\n                    rule = UnpaddedMonthField.INSTANCE;\n                }\n                break;\n            case 'd': \n                rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);\n                break;\n            case 'h': \n                rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));\n                break;\n            case 'H': \n                rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);\n                break;\n            case 'm': \n                rule = selectNumberRule(Calendar.MINUTE, tokenLen);\n                break;\n            case 's': \n                rule = selectNumberRule(Calendar.SECOND, tokenLen);\n                break;\n            case 'S': \n                rule = selectNumberRule(Calendar.MILLISECOND, tokenLen);\n                break;\n            case 'E': \n                rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);\n                break;\n            case 'D': \n                rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);\n                break;\n            case 'F': \n                rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);\n                break;\n            case 'w': \n                rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);\n                break;\n            case 'W': \n                rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);\n                break;\n            case 'a': \n                rule = new TextField(Calendar.AM_PM, AmPmStrings);\n                break;\n            case 'k': \n                rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));\n                break;\n            case 'K': \n                rule = selectNumberRule(Calendar.HOUR, tokenLen);\n                break;\n            case 'z': \n                if (tokenLen >= 4) {\n                    rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG);\n                } else {\n                    rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT);\n                }\n                break;\n            case 'Z': \n                if (tokenLen == 1) {\n                    rule = TimeZoneNumberRule.INSTANCE_NO_COLON;\n                } else {\n                    rule = TimeZoneNumberRule.INSTANCE_COLON;\n                }\n                break;\n            case '\\'': \n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    rule = new CharacterLiteral(sub.charAt(0));\n                } else {\n                    rule = new StringLiteral(sub);\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n            }\n            rules.add(rule);\n        }\n        return rules;\n    }\n", "test_results": ["Plausible"], "patches": ["    protected List<Rule> parsePattern() {\n        DateFormatSymbols symbols = new DateFormatSymbols(mLocale);\n        List<Rule> rules = new ArrayList<Rule>();\n        String[] ERAs = symbols.getEras();\n        String[] months = symbols.getMonths();\n        String[] shortMonths = symbols.getShortMonths();\n        String[] weekdays = symbols.getWeekdays();\n        String[] shortWeekdays = symbols.getShortWeekdays();\n        String[] AmPmStrings = symbols.getAmPmStrings();\n        int length = mPattern.length();\n        int[] indexRef = new int[1];\n        for (int i = 0; i < length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(mPattern, indexRef);\n            i = indexRef[0];\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            Rule rule;\n            char c = token.charAt(0);\n            switch (c) {\n            case 'G': \n                rule = new TextField(Calendar.ERA, ERAs);\n                break;\n            case 'y': \n// buggy code\n//                 if (tokenLen >= 4) {\n//                     rule = selectNumberRule(Calendar.YEAR, tokenLen);\n//                 } else {\n//                     rule = TwoDigitYearField.INSTANCE;\n               if (tokenLen == 2) {\n                    rule = TwoDigitYearField.INSTANCE;\n                } else {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                }\n                break;\n            case 'M': \n                if (tokenLen >= 4) {\n                    rule = new TextField(Calendar.MONTH, months);\n                } else if (tokenLen == 3) {\n                    rule = new TextField(Calendar.MONTH, shortMonths);\n                } else if (tokenLen == 2) {\n                    rule = TwoDigitMonthField.INSTANCE;\n                } else {\n                    rule = UnpaddedMonthField.INSTANCE;\n                }\n                break;\n            case 'd': \n                rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);\n                break;\n            case 'h': \n                rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));\n                break;\n            case 'H': \n                rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);\n                break;\n            case 'm': \n                rule = selectNumberRule(Calendar.MINUTE, tokenLen);\n                break;\n            case 's': \n                rule = selectNumberRule(Calendar.SECOND, tokenLen);\n                break;\n            case 'S': \n                rule = selectNumberRule(Calendar.MILLISECOND, tokenLen);\n                break;\n            case 'E': \n                rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);\n                break;\n            case 'D': \n                rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);\n                break;\n            case 'F': \n                rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);\n                break;\n            case 'w': \n                rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);\n                break;\n            case 'W': \n                rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);\n                break;\n            case 'a': \n                rule = new TextField(Calendar.AM_PM, AmPmStrings);\n                break;\n            case 'k': \n                rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));\n                break;\n            case 'K': \n                rule = selectNumberRule(Calendar.HOUR, tokenLen);\n                break;\n            case 'z': \n                if (tokenLen >= 4) {\n                    rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG);\n                } else {\n                    rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT);\n                }\n                break;\n            case 'Z': \n                if (tokenLen == 1) {\n                    rule = TimeZoneNumberRule.INSTANCE_NO_COLON;\n                } else {\n                    rule = TimeZoneNumberRule.INSTANCE_COLON;\n                }\n                break;\n            case '\\'': \n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    rule = new CharacterLiteral(sub.charAt(0));\n                } else {\n                    rule = new StringLiteral(sub);\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n            }\n            rules.add(rule);\n        }\n        return rules;\n    }\n"], "manual_results": [0]}
{"bug_id": "Jsoup-41", "buggy_code": "    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        if (!super.equals(o)) return false;\n\n        Element element = (Element) o;\n\n        return this == o;\n    }\n", "fixed_code": "    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        if (!super.equals(o)) return false;\n        Element element = (Element) o;\n        return tag.equals(element.tag);\n    }\n", "test_results": ["Plausible", "Plausible", "Plausible", "Plausible"], "patches": ["    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        if (!super.equals(o)) return false;\n        Element element = (Element) o;\n// buggy code\n//         return this == o;\n       return true;\n    }\n", "    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        if (!super.equals(o)) return false;\n        Element element = (Element) o;\n// buggy code\n//         return this == o;\n       return super.equals(o);\n    }\n", "    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        if (!super.equals(o)) return false;\n        Element element = (Element) o;\n// buggy code\n//         return this == o;\n       return this == o || super.equals(o);\n    }\n", "    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        if (!super.equals(o)) return false;\n        Element element = (Element) o;\n// buggy code\n//         return this == o;\n       return this == o || super.equals(element);\n    }\n"], "manual_results": [0, 0, 0, 0]}
{"bug_id": "JacksonCore-8", "buggy_code": "    public char[] getTextBuffer()\n    {\n        // Are we just using shared input buffer?\n        if (_inputStart >= 0) return _inputBuffer;\n        if (_resultArray != null)  return _resultArray;\n        if (_resultString != null) {\n            return (_resultArray = _resultString.toCharArray());\n        }\n        // Nope; but does it fit in just one segment?\n        if (!_hasSegments)  return _currentSegment;\n        // Nope, need to have/create a non-segmented array and return it\n        return contentsAsArray();\n    }\n", "fixed_code": "    public char[] getTextBuffer()\n    {\n        if (_inputStart >= 0) return _inputBuffer;\n        if (_resultArray != null)  return _resultArray;\n        if (_resultString != null) {\n            return (_resultArray = _resultString.toCharArray());\n        }\n        if (!_hasSegments && _currentSegment != null)  return _currentSegment;\n        return contentsAsArray();\n    }\n", "test_results": ["Plausible", "Plausible"], "patches": ["    public char[] getTextBuffer()\n    {\n        if (_inputStart >= 0) return _inputBuffer;\n        if (_resultArray != null)  return _resultArray;\n        if (_resultString != null) {\n            return (_resultArray = _resultString.toCharArray());\n        }\n// buggy code\n//         if (!_hasSegments)  return _currentSegment;\n       if (_currentSegment != null && !_hasSegments)  return _currentSegment;\n        return contentsAsArray();\n    }\n", "    public char[] getTextBuffer()\n    {\n        if (_inputStart >= 0) return _inputBuffer;\n        if (_resultArray != null)  return _resultArray;\n        if (_resultString != null) {\n            return (_resultArray = _resultString.toCharArray());\n        }\n// buggy code\n//         if (!_hasSegments)  return _currentSegment;\n        return contentsAsArray();\n    }\n"], "manual_results": [2, 0]}
{"bug_id": "Compress-7", "buggy_code": "    public static String parseName(byte[] buffer, final int offset, final int length) {\n        StringBuffer result = new StringBuffer(length);\n        int          end = offset + length;\n\n        for (int i = offset; i < end; ++i) {\n            if (buffer[i] == 0) {\n                break;\n            }\n            result.append((char) buffer[i]);\n        }\n\n        return result.toString();\n    }\n", "fixed_code": "    public static String parseName(byte[] buffer, final int offset, final int length) {\n        StringBuffer result = new StringBuffer(length);\n        int          end = offset + length;\n        for (int i = offset; i < end; ++i) {\n            byte b = buffer[i];\n            if (b == 0) { \n                break;\n            }\n            result.append((char) (b & 0xFF)); \n        }\n        return result.toString();\n    }\n", "test_results": ["Plausible", "Plausible"], "patches": ["    public static String parseName(byte[] buffer, final int offset, final int length) {\n        StringBuffer result = new StringBuffer(length);\n        int          end = offset + length;\n        for (int i = offset; i < end; ++i) {\n// buggy code\n//             if (buffer[i] == 0) {\n//                 break;\n//             }\n//             result.append((char) buffer[i]);\n           if (buffer[i] == 0) {\n                break;\n            }\n            result.append((char) (buffer[i] & 0xFF));\n        }\n        return result.toString();\n    }\n", "    public static String parseName(byte[] buffer, final int offset, final int length) {\n        StringBuffer result = new StringBuffer(length);\n        int          end = offset + length;\n        for (int i = offset; i < end; ++i) {\n// buggy code\n//             if (buffer[i] == 0) {\n//                 break;\n//             }\n//             result.append((char) buffer[i]);\n           if (buffer[i] == 0) {\n                break;\n            }\n            result.append((char) (buffer[i] & 0xff));\n        }\n        return result.toString();\n    }\n"], "manual_results": [2, 2]}
{"bug_id": "Closure-109", "buggy_code": "  private Node parseContextTypeExpression(JsDocToken token) {\n          return parseTypeName(token);\n  }\n", "fixed_code": "  private Node parseContextTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.QMARK) {\n      return newNode(Token.QMARK);\n    } else {\n      return parseBasicTypeExpression(token);\n    }\n  }\n", "test_results": ["Plausible"], "patches": ["  private Node parseContextTypeExpression(JsDocToken token) {\n// buggy code\n//           return parseTypeName(token);\n         return parseTypeExpression(token);\n  }\n"], "manual_results": [0]}
{"bug_id": "Math-28", "buggy_code": "    private Integer getPivotRow(SimplexTableau tableau, final int col) {\n        // create a list of all the rows that tie for the lowest score in the minimum ratio test\n        List<Integer> minRatioPositions = new ArrayList<Integer>();\n        double minRatio = Double.MAX_VALUE;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col);\n\n            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                final double ratio = rhs / entry;\n                // check if the entry is strictly equal to the current min ratio\n                // do not use a ulp/epsilon check\n                final int cmp = Double.compare(ratio, minRatio);\n                if (cmp == 0) {\n                    minRatioPositions.add(i);\n                } else if (cmp < 0) {\n                    minRatio = ratio;\n                    minRatioPositions = new ArrayList<Integer>();\n                    minRatioPositions.add(i);\n                }\n            }\n        }\n\n        if (minRatioPositions.size() == 0) {\n            return null;\n        } else if (minRatioPositions.size() > 1) {\n            // there's a degeneracy as indicated by a tie in the minimum ratio test\n\n            // 1. check if there's an artificial variable that can be forced out of the basis\n                for (Integer row : minRatioPositions) {\n                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                        int column = i + tableau.getArtificialVariableOffset();\n                        final double entry = tableau.getEntry(row, column);\n                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n                            return row;\n                        }\n                    }\n                }\n\n            // 2. apply Bland's rule to prevent cycling:\n            //    take the row for which the corresponding basic variable has the smallest index\n            //\n            // see http://www.stanford.edu/class/msande310/blandrule.pdf\n            // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n            //\n            // Additional heuristic: if we did not get a solution after half of maxIterations\n            //                       revert to the simple case of just returning the top-most row\n            // This heuristic is based on empirical data gathered while investigating MATH-828.\n                Integer minRow = null;\n                int minIndex = tableau.getWidth();\n                for (Integer row : minRatioPositions) {\n                    int i = tableau.getNumObjectiveFunctions();\n                    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n                        if (row == tableau.getBasicRow(i)) {\n                            if (i < minIndex) {\n                                minIndex = i;\n                                minRow = row;\n                            }\n                        }\n                    }\n                }\n                return minRow;\n        }\n        return minRatioPositions.get(0);\n    }\n", "fixed_code": "    private Integer getPivotRow(SimplexTableau tableau, final int col) {\n        List<Integer> minRatioPositions = new ArrayList<Integer>();\n        double minRatio = Double.MAX_VALUE;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col);\n            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                final double ratio = rhs / entry;\n                final int cmp = Double.compare(ratio, minRatio);\n                if (cmp == 0) {\n                    minRatioPositions.add(i);\n                } else if (cmp < 0) {\n                    minRatio = ratio;\n                    minRatioPositions = new ArrayList<Integer>();\n                    minRatioPositions.add(i);\n                }\n            }\n        }\n        if (minRatioPositions.size() == 0) {\n            return null;\n        } else if (minRatioPositions.size() > 1) {\n            if (tableau.getNumArtificialVariables() > 0) {\n                for (Integer row : minRatioPositions) {\n                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                        int column = i + tableau.getArtificialVariableOffset();\n                        final double entry = tableau.getEntry(row, column);\n                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n                            return row;\n                        }\n                    }\n                }\n            }\n            if (getIterations() < getMaxIterations() / 2) {\n                Integer minRow = null;\n                int minIndex = tableau.getWidth();\n                for (Integer row : minRatioPositions) {\n                    int i = tableau.getNumObjectiveFunctions();\n                    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n                        if (row == tableau.getBasicRow(i)) {\n                            if (i < minIndex) {\n                                minIndex = i;\n                                minRow = row;\n                            }\n                        }\n                    }\n                }\n                return minRow;\n            }\n        }\n        return minRatioPositions.get(0);\n    }\n", "test_results": ["Plausible", "Plausible"], "patches": ["    private Integer getPivotRow(SimplexTableau tableau, final int col) {\n        List<Integer> minRatioPositions = new ArrayList<Integer>();\n        double minRatio = Double.MAX_VALUE;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col);\n            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                final double ratio = rhs / entry;\n                final int cmp = Double.compare(ratio, minRatio);\n                if (cmp == 0) {\n                    minRatioPositions.add(i);\n                } else if (cmp < 0) {\n                    minRatio = ratio;\n                    minRatioPositions = new ArrayList<Integer>();\n                    minRatioPositions.add(i);\n                }\n            }\n        }\n        if (minRatioPositions.size() == 0) {\n            return null;\n        } else if (minRatioPositions.size() > 1) {\n// buggy code\n//                 for (Integer row : minRatioPositions) {\n//                     for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n//                         int column = i + tableau.getArtificialVariableOffset();\n//                         final double entry = tableau.getEntry(row, column);\n//                         if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n//                             return row;\n//                         }\n//                     }\n//                 }\n//                 Integer minRow = null;\n//                 int minIndex = tableau.getWidth();\n//                 for (Integer row : minRatioPositions) {\n//                     int i = tableau.getNumObjectiveFunctions();\n//                     for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n//                         if (row == tableau.getBasicRow(i)) {\n//                             if (i < minIndex) {\n//                                 minIndex = i;\n//                                 minRow = row;\n//                             }\n//                         }\n//                     }\n//                 }\n//                 return minRow;\n           Integer minRow = null;\n            int minIndex = tableau.getWidth();\n            for (Integer row : minRatioPositions) {\n                int i = tableau.getNumObjectiveFunctions();\n                for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n                    if (row == tableau.getBasicRow(i)) {\n                        if (i < minIndex) {\n                            minIndex = i;\n                            minRow = row;\n                        }\n                    }\n                }\n            }\n            return minRow;\n        }\n        return minRatioPositions.get(0);\n    }\n", "    private Integer getPivotRow(SimplexTableau tableau, final int col) {\n        List<Integer> minRatioPositions = new ArrayList<Integer>();\n        double minRatio = Double.MAX_VALUE;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col);\n            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                final double ratio = rhs / entry;\n                final int cmp = Double.compare(ratio, minRatio);\n                if (cmp == 0) {\n                    minRatioPositions.add(i);\n                } else if (cmp < 0) {\n                    minRatio = ratio;\n                    minRatioPositions = new ArrayList<Integer>();\n                    minRatioPositions.add(i);\n                }\n            }\n        }\n        if (minRatioPositions.size() == 0) {\n            return null;\n        } else if (minRatioPositions.size() > 1) {\n// buggy code\n//                 for (Integer row : minRatioPositions) {\n//                     for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n//                         int column = i + tableau.getArtificialVariableOffset();\n//                         final double entry = tableau.getEntry(row, column);\n//                         if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n//                             return row;\n//                         }\n//                     }\n//                 }\n//                 Integer minRow = null;\n//                 int minIndex = tableau.getWidth();\n//                 for (Integer row : minRatioPositions) {\n//                     int i = tableau.getNumObjectiveFunctions();\n//                     for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n//                         if (row == tableau.getBasicRow(i)) {\n//                             if (i < minIndex) {\n//                                 minIndex = i;\n//                                 minRow = row;\n//                             }\n//                         }\n//                     }\n//                 }\n//                 return minRow;\n           Integer minRow = null;\n            int minIndex = tableau.getWidth();\n            for (Integer row : minRatioPositions) {\n                int i = tableau.getNumObjectiveFunctions();\n                for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n                    if (row == tableau.getBasicRow(i)) {\n                        if (i < minIndex) {\n                            minIndex = i;\n                            minRow = row;\n                        }\n                    }\n                }\n            }\n            return minRow;\n        } else {\n        }\n        return minRatioPositions.get(0);\n    }\n"], "manual_results": [0, 0]}
{"bug_id": "Time-20", "buggy_code": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            String str = text.substring(position);\n            for (String id : ALL_IDS) {\n                if (str.startsWith(id)) {\n                    bucket.setZone(DateTimeZone.forID(id));\n                    return position + id.length();\n                }\n            }\n            return ~position;\n        }\n", "fixed_code": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            String str = text.substring(position);\n            String best = null;\n            for (String id : ALL_IDS) {\n                if (str.startsWith(id)) {\n                \tif (best == null || id.length() > best.length()) {\n                \t\tbest = id;\n                \t}\n                }\n            }\n            if (best != null) {\n                bucket.setZone(DateTimeZone.forID(best));\n                return position + best.length();\n            }\n            return ~position;\n        }\n", "test_results": ["Plausible"], "patches": ["        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            String str = text.substring(position);\n// buggy code\n//             for (String id : ALL_IDS) {\n//                 if (str.startsWith(id)) {\n//                     bucket.setZone(DateTimeZone.forID(id));\n//                     return position + id.length();\n//                 }\n           for (int i = str.length() - 1; i >= 0; i--) {\n                String id = str.substring(0, i + 1);\n                if (ALL_IDS.contains(id)) {\n                    bucket.setZone(DateTimeZone.forID(id));\n                    return position + id.length();\n                }\n            }\n            return ~position;\n        }\n"], "manual_results": [0]}
{"bug_id": "Math-53", "buggy_code": "    public Complex add(Complex rhs)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(rhs);\n        return createComplex(real + rhs.getReal(),\n            imaginary + rhs.getImaginary());\n    }\n", "fixed_code": "    public Complex add(Complex rhs)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(rhs);\n        if (isNaN || rhs.isNaN) {\n            return NaN;\n        }\n        return createComplex(real + rhs.getReal(),\n            imaginary + rhs.getImaginary());\n    }\n", "test_results": ["Plausible", "Plausible"], "patches": ["    public Complex add(Complex rhs)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(rhs);\n// buggy code\n// \n       if (isNaN() || rhs.isNaN()) {\n            return NaN;\n        }\n        return createComplex(real + rhs.getReal(),\n            imaginary + rhs.getImaginary());\n    }\n", "    public Complex add(Complex rhs)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(rhs);\n// buggy code\n// \n       if (rhs.isNaN()) {\n            return NaN;\n        }\n        return createComplex(real + rhs.getReal(),\n            imaginary + rhs.getImaginary());\n    }\n"], "manual_results": [2, 0]}
{"bug_id": "Jsoup-54", "buggy_code": "        private void copyAttributes(org.jsoup.nodes.Node source, Element el) {\n            for (Attribute attribute : source.attributes()) {\n                // valid xml attribute names are: ^[a-zA-Z_:][-a-zA-Z0-9_:.]\n                String key = attribute.getKey().replaceAll(\"[^-a-zA-Z0-9_:.]\", \"\");\n                    el.setAttribute(key, attribute.getValue());\n            }\n        }\n", "fixed_code": "        private void copyAttributes(org.jsoup.nodes.Node source, Element el) {\n            for (Attribute attribute : source.attributes()) {\n                String key = attribute.getKey().replaceAll(\"[^-a-zA-Z0-9_:.]\", \"\");\n                if (key.matches(\"[a-zA-Z_:]{1}[-a-zA-Z0-9_:.]*\"))\n                    el.setAttribute(key, attribute.getValue());\n            }\n        }\n", "test_results": ["Plausible", "Plausible", "Plausible", "Plausible", "Plausible", "Plausible"], "patches": ["        private void copyAttributes(org.jsoup.nodes.Node source, Element el) {\n            for (Attribute attribute : source.attributes()) {\n                String key = attribute.getKey().replaceAll(\"[^-a-zA-Z0-9_:.]\", \"\");\n// buggy code\n// \n               if (key.length() > 0)\n                    el.setAttribute(key, attribute.getValue());\n            }\n        }\n", "        private void copyAttributes(org.jsoup.nodes.Node source, Element el) {\n            for (Attribute attribute : source.attributes()) {\n                String key = attribute.getKey().replaceAll(\"[^-a-zA-Z0-9_:.]\", \"\");\n// buggy code\n// \n               if (!key.isEmpty())\n                    el.setAttribute(key, attribute.getValue());\n            }\n        }\n", "        private void copyAttributes(org.jsoup.nodes.Node source, Element el) {\n            for (Attribute attribute : source.attributes()) {\n                String key = attribute.getKey().replaceAll(\"[^-a-zA-Z0-9_:.]\", \"\");\n// buggy code\n// \n               if (!key.equals(\"\"))\n                    el.setAttribute(key, attribute.getValue());\n            }\n        }\n", "        private void copyAttributes(org.jsoup.nodes.Node source, Element el) {\n            for (Attribute attribute : source.attributes()) {\n                String key = attribute.getKey().replaceAll(\"[^-a-zA-Z0-9_:.]\", \"\");\n// buggy code\n// \n               if (!\"\".equals(key))\n                    el.setAttribute(key, attribute.getValue());\n            }\n        }\n", "        private void copyAttributes(org.jsoup.nodes.Node source, Element el) {\n            for (Attribute attribute : source.attributes()) {\n                String key = attribute.getKey().replaceAll(\"[^-a-zA-Z0-9_:.]\", \"\");\n// buggy code\n// \n               if (key.isEmpty()) {\n                    continue;\n                }\n                    el.setAttribute(key, attribute.getValue());\n            }\n        }\n", "        private void copyAttributes(org.jsoup.nodes.Node source, Element el) {\n            for (Attribute attribute : source.attributes()) {\n                String key = attribute.getKey().replaceAll(\"[^-a-zA-Z0-9_:.]\", \"\");\n// buggy code\n// \n               if (key.length() == 0)\n                    continue;\n                    el.setAttribute(key, attribute.getValue());\n            }\n        }\n"], "manual_results": [0, 0, 0, 0, 0, 0]}
{"bug_id": "Jsoup-51", "buggy_code": "    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n    }\n", "fixed_code": "    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c);\n    }\n", "test_results": ["Plausible"], "patches": ["    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n// buggy code\n//         return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n       return Character.isLetter(c);\n    }\n"], "manual_results": [0]}
{"bug_id": "Csv-15", "buggy_code": "    private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n            final Appendable out, final boolean newRecord) throws IOException {\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delimChar = getDelimiter();\n        final char quoteChar = getQuoteCharacter().charValue();\n\n        QuoteMode quoteModePolicy = getQuoteMode();\n        if (quoteModePolicy == null) {\n            quoteModePolicy = QuoteMode.MINIMAL;\n        }\n        switch (quoteModePolicy) {\n        case ALL:\n        case ALL_NON_NULL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // Use the existing escaping code\n            printAndEscape(value, offset, len, out);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                // always quote an empty token that is the first\n                // on the line, as it may be the only thing on the\n                // line. If it were not quoted in that case,\n                // an empty line has no tokens.\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = value.charAt(pos);\n\n                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n                    quote = true;\n                } else if (c <= COMMENT) {\n                    // Some other chars at the start of a value caused the parser to fail, so for now\n                    // encapsulate if we start in anything less than '#'. We are being conservative\n                    // by including the default comment char too.\n                    quote = true;\n                } else {\n                    while (pos < end) {\n                        c = value.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n\n                    if (!quote) {\n                        pos = end - 1;\n                        c = value.charAt(pos);\n                        // Some other chars at the end caused the parser to fail, so for now\n                        // encapsulate if we end in anything less than ' '\n                        if (c <= SP) {\n                            quote = true;\n                        }\n                    }\n                }\n            }\n\n            if (!quote) {\n                // no encapsulation needed - write out the original value\n                out.append(value, start, end);\n                return;\n            }\n            break;\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(quoteChar);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            final char c = value.charAt(pos);\n            if (c == quoteChar) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(quoteChar);\n    }\n", "fixed_code": "    private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n            final Appendable out, final boolean newRecord) throws IOException {\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n        final char delimChar = getDelimiter();\n        final char quoteChar = getQuoteCharacter().charValue();\n        QuoteMode quoteModePolicy = getQuoteMode();\n        if (quoteModePolicy == null) {\n            quoteModePolicy = QuoteMode.MINIMAL;\n        }\n        switch (quoteModePolicy) {\n        case ALL:\n        case ALL_NON_NULL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            printAndEscape(value, offset, len, out);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = value.charAt(pos);\n                if (c <= COMMENT) {\n                    quote = true;\n                } else {\n                    while (pos < end) {\n                        c = value.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n                    if (!quote) {\n                        pos = end - 1;\n                        c = value.charAt(pos);\n                        if (c <= SP) {\n                            quote = true;\n                        }\n                    }\n                }\n            }\n            if (!quote) {\n                out.append(value, start, end);\n                return;\n            }\n            break;\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n        }\n        if (!quote) {\n            out.append(value, start, end);\n            return;\n        }\n        out.append(quoteChar);\n        while (pos < end) {\n            final char c = value.charAt(pos);\n            if (c == quoteChar) {\n                out.append(value, start, pos + 1);\n                start = pos;\n            }\n            pos++;\n        }\n        out.append(value, start, pos);\n        out.append(quoteChar);\n    }\n", "test_results": ["Plausible"], "patches": ["    private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n            final Appendable out, final boolean newRecord) throws IOException {\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n        final char delimChar = getDelimiter();\n        final char quoteChar = getQuoteCharacter().charValue();\n        QuoteMode quoteModePolicy = getQuoteMode();\n        if (quoteModePolicy == null) {\n            quoteModePolicy = QuoteMode.MINIMAL;\n        }\n        switch (quoteModePolicy) {\n        case ALL:\n        case ALL_NON_NULL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            printAndEscape(value, offset, len, out);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = value.charAt(pos);\n// buggy code\n//                 if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n//                     quote = true;\n//                 } else if (c <= COMMENT) {\n               if (!newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n                    quote = true;\n                } else if (c <= COMMENT) {\n                    quote = true;\n                } else {\n                    while (pos < end) {\n                        c = value.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n                    if (!quote) {\n                        pos = end - 1;\n                        c = value.charAt(pos);\n                        if (c <= SP) {\n                            quote = true;\n                        }\n                    }\n                }\n            }\n            if (!quote) {\n                out.append(value, start, end);\n                return;\n            }\n            break;\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n        }\n        if (!quote) {\n            out.append(value, start, end);\n            return;\n        }\n        out.append(quoteChar);\n        while (pos < end) {\n            final char c = value.charAt(pos);\n            if (c == quoteChar) {\n                out.append(value, start, pos + 1);\n                start = pos;\n            }\n            pos++;\n        }\n        out.append(value, start, pos);\n        out.append(quoteChar);\n    }\n"], "manual_results": [0]}
{"bug_id": "Compress-25", "buggy_code": "    public ZipArchiveInputStream(InputStream inputStream,\n                                 String encoding,\n                                 boolean useUnicodeExtraFields,\n                                 boolean allowStoredEntriesWithDataDescriptor) {\n        zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n        this.useUnicodeExtraFields = useUnicodeExtraFields;\n        in = new PushbackInputStream(inputStream, buf.capacity());\n        this.allowStoredEntriesWithDataDescriptor =\n            allowStoredEntriesWithDataDescriptor;\n        // haven't read anything so far\n    }\n", "fixed_code": "    public ZipArchiveInputStream(InputStream inputStream,\n                                 String encoding,\n                                 boolean useUnicodeExtraFields,\n                                 boolean allowStoredEntriesWithDataDescriptor) {\n        zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n        this.useUnicodeExtraFields = useUnicodeExtraFields;\n        in = new PushbackInputStream(inputStream, buf.capacity());\n        this.allowStoredEntriesWithDataDescriptor =\n            allowStoredEntriesWithDataDescriptor;\n        buf.limit(0);\n    }\n", "test_results": ["Plausible", "Plausible"], "patches": ["    public ZipArchiveInputStream(InputStream inputStream,\n                                 String encoding,\n                                 boolean useUnicodeExtraFields,\n                                 boolean allowStoredEntriesWithDataDescriptor) {\n        zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n        this.useUnicodeExtraFields = useUnicodeExtraFields;\n        in = new PushbackInputStream(inputStream, buf.capacity());\n        this.allowStoredEntriesWithDataDescriptor =\n            allowStoredEntriesWithDataDescriptor;\n// buggy code\n// \n       buf.position(buf.capacity());\n    }\n", "    public ZipArchiveInputStream(InputStream inputStream,\n                                 String encoding,\n                                 boolean useUnicodeExtraFields,\n                                 boolean allowStoredEntriesWithDataDescriptor) {\n        zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n        this.useUnicodeExtraFields = useUnicodeExtraFields;\n        in = new PushbackInputStream(inputStream, buf.capacity());\n        this.allowStoredEntriesWithDataDescriptor =\n            allowStoredEntriesWithDataDescriptor;\n// buggy code\n// \n       buf.position(buf.capacity()); \n    }\n"], "manual_results": [0, 0]}
{"bug_id": "Closure-128", "buggy_code": "  static boolean isSimpleNumber(String s) {\n    int len = s.length();\n    for (int index = 0; index < len; index++) {\n      char c = s.charAt(index);\n      if (c < '0' || c > '9') {\n        return false;\n      }\n    }\n    return len > 0 && s.charAt(0) != '0';\n  }\n", "fixed_code": "  static boolean isSimpleNumber(String s) {\n    int len = s.length();\n    if (len == 0) {\n      return false;\n    }\n    for (int index = 0; index < len; index++) {\n      char c = s.charAt(index);\n      if (c < '0' || c > '9') {\n        return false;\n      }\n    }\n    return len == 1 || s.charAt(0) != '0';\n  }\n", "test_results": ["Plausible"], "patches": ["  static boolean isSimpleNumber(String s) {\n    int len = s.length();\n// buggy code\n//     for (int index = 0; index < len; index++) {\n//       char c = s.charAt(index);\n//       if (c < '0' || c > '9') {\n//         return false;\n//       }\n//     }\n//     return len > 0 && s.charAt(0) != '0';\n   if (len == 0) {\n      return false;\n    }\n    for (int index = 0; index < len; index++) {\n      char c = s.charAt(index);\n      if (c < '0' || c > '9') {\n        return false;\n      }\n    }\n    return s.charAt(0) != '0' || len == 1;\n  }\n"], "manual_results": [2]}
{"bug_id": "Math-34", "buggy_code": "    public Iterator<Chromosome> iterator() {\n        return chromosomes.iterator();\n    }\n", "fixed_code": "    public Iterator<Chromosome> iterator() {\n        return getChromosomes().iterator();\n    }\n", "test_results": ["Plausible", "Plausible", "Plausible", "Plausible"], "patches": ["    public Iterator<Chromosome> iterator() {\n// buggy code\n//         return chromosomes.iterator();\n       return Collections.unmodifiableCollection(chromosomes).iterator();\n    }\n", "    public Iterator<Chromosome> iterator() {\n// buggy code\n//         return chromosomes.iterator();\n       return Collections.unmodifiableList(chromosomes).iterator();\n    }\n", "    public Iterator<Chromosome> iterator() {\n// buggy code\n//         return chromosomes.iterator();\n       return new Iterator<Chromosome>() {\n            int i = 0;\n            @Override\n            public boolean hasNext() {\n                return i < chromosomes.size();\n            }\n\n            @Override\n            public Chromosome next() {\n                return chromosomes.get(i++);\n            }\n        };\n    }\n", "    public Iterator<Chromosome> iterator() {\n// buggy code\n//         return chromosomes.iterator();\n       return new Iterator<Chromosome>() {\n            int index = 0;\n            @Override\n            public boolean hasNext() {\n                return index < chromosomes.size();\n            }\n\n            @Override\n            public Chromosome next() {\n                return chromosomes.get(index++);\n            }\n        };\n    }\n"], "manual_results": [0, 0, 0, 0]}
